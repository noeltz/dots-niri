#!/bin/sh
#description: find dominant colors in images
#usage: n0_image_analyzer image-file

#example: n0_image_analyzer black-and-white-image.png
#output 3 dominant colors in rgb format
#191,191,191
#80,80,80
#185,185,185

PROGNAME="$(expr "${0}" : '.*/\([^/]*\)')"

_usage() {
    printf "Usage: %s\\n" "${PROGNAME} [options] image-file ..."
    printf "%s\\n" "Find dominant colors in images."
    printf "\\n"
    printf "%s\\n" "  -d, --deviation   deviation, higher value, faster computation, default 1"
    printf "%s\\n" "  -n, --numcolors   number of output colors (using quantization), default 3"
    printf "%s\\n" "  -r, --resize      resize before procedure, lower value, faster computation, default 250x250"
    printf "%s\\n" "  -f, --format      output format [rgb|hex], default hex"
    printf "%s\\n" "  -s, --sort        sort method [percentage|vibrance], default percentage"
    printf "%s\\n" "  -p, --preview     preview colors in command line"
    printf "%s\\n" "  -q, --quiet       suppress warnings"
    printf "%s\\n" "  --version         show version information and exit"
    printf "%s\\n" "  -h, --help        show this help message and exit"
}

_die() {
    [ -z "${1}" ] || printf "%s\\n" "${*}" >&2
    _usage >&2; exit 1
}

_is_int() {
    #look for an integer, returns 0 on success, 1 otherwise
    #http://www.unix.com/shell-programming-and-scripting/172070-help-scripting-command.html
    case "${1}" in
        *[!0-9]*|"") return 1 ;;
    esac
}

_is_resize_format() {
    # Check if resize format is valid (e.g., 25x25)
    case "${1}" in
        *[!0-9x]*|"") return 1 ;;  # Contains non-digit, non-x characters or empty
        *x*) : ;;  # Contains 'x'
        *) return 1 ;;
    esac
}

_validate_image() {
    local image="$1"
    if [ ! -f "${image}" ]; then
        printf "%s\\n" "Error: '${image}' doesn't exist" >&2
        return 1
    fi

    # Check if ImageMagick can read the file
    if ! convert "${image}" -format "" info: >/dev/null 2>&1; then
        printf "%s\\n" "Error: '${image}' is not a supported image format" >&2
        return 1
    fi
}

_quantize_colors() {
    # Function to find dominant colors using ImageMagick's quantization
    # This is more effective for preserving diverse colors than k-means on histogram
    local image="$1"
    local num_colors="$2"
    local format="$3"
    local sort_method="$4"
    # Parameter 5 is no longer used since brightness is handled separately in main execution flow

    # Use ImageMagick's quantization to reduce colors to the specified number
    # First resize the image to a reasonable size (similar to what dominantcolor does)
    # Then apply color quantization
    colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
        -format "%c" histogram:info: 2>/dev/null | \
        awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
        sort -t, -k1,1nr)

    # Collect all color data with percentage and vibrance information (using pipe delimiter to avoid comma conflicts)
    temp_file=$(mktemp)
    temp_vibrance_file=$(mktemp)

    # Process the output to extract color counts and convert to required format
    echo "$colors_output" | while IFS= read -r line; do
        if [ -n "$line" ]; then
            # Extract total pixel count and color
            total_pixels=$(echo "$line" | cut -d: -f1)
            color_part=$(echo "$line" | cut -d: -f2-)

            if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                # Calculate percentage (always calculated and shown now)
                # For relative percentages within the quantized result
                # We need to calculate based on the total pixels in the quantized image
                # Get the total pixels in the resized image
                resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                    percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.6f", ($1*100.0)/$2}')
                else
                    percentage="0.000000"
                fi

                # Calculate vibrance based on saturation (max - min of RGB values)
                IFS=',' read -r r g b <<< "$color_part"
                # Ensure values are valid and convert to integers for vibrance calculation
                r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                # Calculate saturation as the difference between max and min RGB values
                # This will give us the vibrance value
                if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                    max_val="$r_int"
                elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                    max_val="$g_int"
                else
                    max_val="$b_int"
                fi

                if [ "$r_int" -le "$g_int" ] && [ "$r_int" -le "$b_int" ]; then
                    min_val="$r_int"
                elif [ "$g_int" -le "$r_int" ] && [ "$g_int" -le "$b_int" ]; then
                    min_val="$g_int"
                else
                    min_val="$b_int"
                fi

                vibrance=$((max_val - min_val))

                # Store data for sorting - format: "r_int|g_int|b_int|percentage|vibrance" for rgb, or "hex_color|percentage|vibrance" for hex
                if [ "$format" = "rgb" ]; then
                    echo "$r_int|$g_int|$b_int|$percentage|$vibrance" >> "$temp_vibrance_file"
                else
                    hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")
                    echo "$hex_color|$percentage|$vibrance" >> "$temp_vibrance_file"
                fi
            fi
        fi
    done

    # Wait for all background processes to complete
    wait

    # Sort based on the selected method
    if [ "$sort_method" = "vibrance" ]; then
        # Sort by vibrance (the last field, descending)
        if [ "$format" = "rgb" ]; then
            sort -t'|' -k5,5nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract RGB and percentage, excluding vibrance for output (first 4 fields)
                r_val=$(echo "$line" | cut -d'|' -f1)
                g_val=$(echo "$line" | cut -d'|' -f2)
                b_val=$(echo "$line" | cut -d'|' -f3)
                percentage=$(echo "$line" | cut -d'|' -f4)
                echo "$r_val,$g_val,$b_val,$percentage"
            done
        else
            sort -t'|' -k3,3nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract hex and percentage, excluding vibrance for output (first 2 fields)
                hex_color=$(echo "$line" | cut -d'|' -f1)
                percentage=$(echo "$line" | cut -d'|' -f2)
                echo "$hex_color ($percentage%)"
            done
        fi
    else
        # Sort by percentage (default behavior, descending)
        if [ "$format" = "rgb" ]; then
            sort -t'|' -k4,4nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract RGB and percentage, excluding vibrance for output (first 4 fields)
                r_val=$(echo "$line" | cut -d'|' -f1)
                g_val=$(echo "$line" | cut -d'|' -f2)
                b_val=$(echo "$line" | cut -d'|' -f3)
                percentage=$(echo "$line" | cut -d'|' -f4)
                echo "$r_val,$g_val,$b_val,$percentage"
            done
        else
            sort -t'|' -k2,2nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract hex and percentage, excluding vibrance for output (first 2 fields)
                hex_color=$(echo "$line" | cut -d'|' -f1)
                percentage=$(echo "$line" | cut -d'|' -f2)
                echo "$hex_color ($percentage%)"
            done
        fi
    fi

    # Clean up temp files
    rm -f "$temp_file" "$temp_vibrance_file"
}

_get_brightness_by_dominant_colors() {
    # Function to calculate brightness based on dominant colors
    # Uses quantization to get dominant colors and analyzes their brightness
    # When using only 2 colors, focuses on the most dominant one
    local image="$1"
    local num_colors="${2:-8}"  # Default to 8 dominant colors, caller can specify more

    # Use ImageMagick's quantization to get dominant colors
    dominant_colors=$(convert "${image}" -resize 100x100! -depth 8 +dither -colors "$num_colors" \
        -format "%c" histogram:info: 2>/dev/null)

    if [ -n "$dominant_colors" ]; then
        if [ "$num_colors" -le 2 ]; then
            # When using only 2 colors, get the brightness of the most dominant one
            brightness_result=$(echo "$dominant_colors" | awk '
            {
                # Split the line to get the count and RGB values
                # Format: "COUNT: (R,G,B) #HEX srgb(...)"
                colon_pos = index($0, ":");
                if (colon_pos > 0) {
                    count = substr($0, 1, colon_pos-1);

                    # Extract RGB values from "(R,G,B)" format
                    paren_start = index($0, "(");
                    paren_end = index($0, ")");
                    if (paren_start > 0 && paren_end > paren_start) {
                        rgb_str = substr($0, paren_start+1, paren_end-paren_start-1);
                        split(rgb_str, rgb_vals, ",");
                        red = rgb_vals[1];
                        green = rgb_vals[2];
                        blue = rgb_vals[3];

                        # Calculate luminance using standard formula: 0.299*R + 0.587*G + 0.114*B
                        luminance = 0.299 * red + 0.587 * green + 0.114 * blue;

                        # Store count and luminance
                        color_counts[NR] = count;
                        color_luminances[NR] = luminance;

                        # Keep track of the most dominant color index
                        if (count > max_count) {
                            max_count = count;
                            most_dominant_idx = NR;
                        }
                    }
                }
            }
            END {
                if (most_dominant_idx != "") {
                    # Return luminance of the most dominant color
                    printf "%.0f", color_luminances[most_dominant_idx];
                } else {
                    print 128; # Default if no dominant color found
                }
            }')
        else
            # For more than 2 colors, use weighted average (original behavior)
            brightness_result=$(echo "$dominant_colors" | awk '
            {
                # Split the line to get the count and RGB values
                # Format: "COUNT: (R,G,B) #HEX srgb(...)"
                colon_pos = index($0, ":");
                if (colon_pos > 0) {
                    count = substr($0, 1, colon_pos-1);

                    # Extract RGB values from "(R,G,B)" format
                    paren_start = index($0, "(");
                    paren_end = index($0, ")");
                    if (paren_start > 0 && paren_end > paren_start) {
                        rgb_str = substr($0, paren_start+1, paren_end-paren_start-1);
                        split(rgb_str, rgb_vals, ",");
                        red = rgb_vals[1];
                        green = rgb_vals[2];
                        blue = rgb_vals[3];

                        # Calculate luminance using standard formula: 0.299*R + 0.587*G + 0.114*B
                        luminance = 0.299 * red + 0.587 * green + 0.114 * blue;

                        total_luminance += luminance * count;
                        total_count += count;
                    }
                }
            }
            END {
                if (total_count > 0) {
                    avg_brightness = total_luminance / total_count;
                    printf "%.0f", avg_brightness;
                } else {
                    print 128; # Default if no dominant colors found
                }
            }')
        fi

        if [ -n "$brightness_result" ]; then
            printf "%s" "$brightness_result"
            return
        fi
    fi

    # Fallback: if dominant color analysis fails, use original method
    avg_brightness=$(convert "${image}" -colorspace Gray -resize 1x1 -format "%[fx:255*u]" info:- 2>/dev/null)
    if [ -n "$avg_brightness" ]; then
        avg_brightness=$(echo "$avg_brightness" | awk '{if(NF>0) printf "%.0f", $1; else print "128"}')
        printf "%s" "$avg_brightness"
    else
        printf "128"
    fi
}

_get_brightness() {
    # Function to calculate brightness based on top 2 dominant colors (main entry point)
    local image="$1"

    # Use dominant color analysis with top 2 colors only, based on the most prominent one
    _get_brightness_by_dominant_colors "$image" "2"
}

_categorize_brightness() {
    # Function to determine if image is dark or light based on dominant color analysis
    # With dominant colors, we might want a different threshold than for average brightness
    local brightness="$1"
    local image="$2"  # Optional: Pass image path to potentially get more dominant colors

    # Use a more appropriate threshold for dominant color based brightness
    # Since dominant colors represent the most significant visual elements,
    # a threshold around 128-135 might be more appropriate
    if [ "$brightness" -lt 135 ]; then
        printf "dark"
    else
        printf "light"
    fi
}

_display_color_preview() {
    # Function to display color preview using ANSI escape codes
    local color="$1"
    local format="$2"

    if [ "$format" = "hex" ]; then
        # Convert hex to RGB for ANSI codes if needed, but for now we'll use the color as provided
        # Extract RGB values from hex for ANSI code
        if [ ${#color} -eq 7 ] && [ "${color#?}" != "$color" ]; then
            # Remove # and extract RGB values
            hex_color="${color#'#'}"
            r=$(printf "%d" 0x${hex_color:0:2})
            g=$(printf "%d" 0x${hex_color:2:2})
            b=$(printf "%d" 0x${hex_color:4:2})
        fi
    else
        # Assuming RGB format: r,g,b
        old_IFS="$IFS"
        IFS=',' read -r r g b << EOF
$color
EOF
        IFS="$old_IFS"
    fi

    # Ensure values are valid and convert to integers for ANSI escape sequence
    # Use awk for safer number handling
    r=$(echo "$r" | awk '{printf "%.0f", $1}')
    g=$(echo "$g" | awk '{printf "%.0f", $1}')
    b=$(echo "$b" | awk '{printf "%.0f", $1}')

    # ANSI escape code for background color
    printf "\\033[48;2;%s;%s;%sm    \\033[0m %s\\n" "$r" "$g" "$b" "$color"
}


_false() {
    return 1
}


_check_deps() {
    if command -v "awk" >/dev/null 2>&1; then
        awk_bin="awk"
    elif busybox awk 1 /dev/null >/dev/null 2>&1; then
        awk_bin="busybox awk"
    else
        printf "%s\\n" "Error: 'awk' is required to run this program. Please install gawk or mawk." >&2
        exit 1
    fi

    if ! command -v "convert" >/dev/null 2>&1; then
        printf "%s\\n" "Error: 'convert' (ImageMagick) is required to run this program. Please install ImageMagick." >&2
        exit 1
    fi
}

_sanitize_parameters(){
    if [ -z "${num_colors}" ]; then
        num_colors="3"
    else
        _is_int "${num_colors}" || _die "Option -n|--numcolors requires a number parameter '${num_colors}'"
    fi

    if [ -z "${deviation}" ]; then
        deviation="1"
    else
        _is_int "${deviation}" || _die "Option -d|--deviation requires a number parameter '${deviation}'"
    fi

    if [ -z "${format}" ]; then
        format="hex"
    else
        case "${format}" in
            rgb|hex) : ;;
            *) _die "Output valid formats are rgb|hex: '${format}'" ;;
        esac
    fi

    if [ -z "${resize}" ]; then
        resize="25x25"
    else
        _is_resize_format "${resize}" || _die "Option -r|--resize requires a format like '25x25': '${resize}'"
    fi

    if [ -z "${sort}" ]; then
        sort="percentage"
    else
        case "${sort}" in
            percentage|vibrance) : ;;
            *) _die "Output sort methods are percentage|vibrance: '${sort}'" ;;
        esac
    fi
}

# Initialize preview, sort method, and method flags
preview=""
sort="percentage"  # Default to sorting by percentage
method="quantize"  # Default to quantize for better results
resize="800x600"   # Default to larger resize for better color detection

if [ ! -t 0 ]; then
    #there is input comming from pipe or file, add to the end of $@
    set -- "${@}" $(cat)
fi

for arg in "${@}"; do #parse options
    case "${arg}" in
        --version) printf "%s %s\\n" "${PROGNAME}" "1.1"; exit ;;
        -h|--help) _usage && exit ;;
        '-p'|'--preview') preview="1"; shift ;;
        '-q'|'--quiet') quiet="1"; shift ;;
        '-d'|'--deviation')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; deviation="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -d*) deviation="${1#-d}"; shift ;;
        --deviation*) deviation="${1#--deviation}"; shift ;;
        '-n'|'--numcolors')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; num_colors="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -n*) num_colors="${1#-n}"; shift ;;
        --numcolors*) num_colors="${1#--numcolors}"; shift ;;
        '-r'|'--resize')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; resize="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -r*) resize="${1#-r}"; shift ;;
        --resize*) resize="${1#--resize}"; shift ;;
        '-f'|'--format')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; format="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        '-s'|'--sort')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; sort="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -s*) sort="${1#-s}"; shift ;;
        --sort*) sort="${1#--sort}"; shift ;;
        '-f'|'--format')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; format="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -f*) format="${1#-f}"; shift ;;
        --format*) format="${1#--format}"; shift ;;
        -*) _die "${PROGNAME}: unrecognized option '${arg}'" ;;
    esac
done

_check_deps && _sanitize_parameters && [ "${#}" -eq "0" ] && _die

# Use quantization method only (default method)
for image; do
    if _validate_image "${image}"; then
        # Determine if we need to show percentages (always show percentages for pipe output)
        show_percent="1"

        if [ -n "${preview}" ]; then
            # Process for preview output
            # Calculate brightness and show it as in non-preview mode
            brightness_value=$(_get_brightness "${image}")
            brightness_category=$(_categorize_brightness "${brightness_value}" "${image}")
            printf "BRIGHTNESS:%s\\n" "${brightness_category}"

            # Use ImageMagick's quantization to reduce colors to the specified number
            colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}')

            # Collect color data with percentage and vibrance for sorting (using pipe delimiter to avoid comma conflicts)
            temp_vibrance_file=$(mktemp)

            echo "$colors_output" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract total pixel count and color
                    total_pixels=$(echo "$line" | cut -d: -f1)
                    color_part=$(echo "$line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage for display
                        resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.6f", ($1*100.0)/$2}')
                        else
                            percentage="0.000000"
                        fi

                        # Calculate vibrance based on saturation (max - min of RGB values)
                        IFS=',' read -r r g b <<< "$color_part"
                        # Ensure values are valid and convert to integers for vibrance calculation
                        r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                        # Calculate saturation as the difference between max and min RGB values
                        # This will give us the vibrance value
                        if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                            max_val="$r_int"
                        elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                            max_val="$g_int"
                        else
                            max_val="$b_int"
                        fi

                        if [ "$r_int" -le "$g_int" ] && [ "$r_int" -le "$b_int" ]; then
                            min_val="$r_int"
                        elif [ "$g_int" -le "$r_int" ] && [ "$g_int" -le "$b_int" ]; then
                            min_val="$g_int"
                        else
                            min_val="$b_int"
                        fi

                        vibrance=$((max_val - min_val))

                        # Store data for sorting - format: "original_count|color_part|percentage|vibrance"
                        # Using pipe delimiter to avoid conflicts with commas in color_part
                        echo "$total_pixels|$color_part|$percentage|$vibrance" >> "$temp_vibrance_file"
                    fi
                fi
            done

            # Wait for all background processes to complete
            wait

            # Sort based on the selected method
            if [ "$sort" = "vibrance" ]; then
                # Sort by vibrance (the 4th field after splitting by pipe, descending)
                sorted_colors=$(sort -t'|' -k4,4nr "$temp_vibrance_file")
            else
                # Sort by percentage (the 3rd field after splitting by pipe, descending)
                sorted_colors=$(sort -t'|' -k3,3nr "$temp_vibrance_file")
            fi

            # Process the sorted output to create preview
            echo "$sorted_colors" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract parts: original_count|color_part|percentage|vibrance
                    original_count=$(echo "$line" | cut -d'|' -f1)
                    color_part=$(echo "$line" | cut -d'|' -f2)
                    percentage=$(echo "$line" | cut -d'|' -f3)
                    # vibrance is in the 4th field but we don't need it for output

                    # Convert RGB to appropriate format based on selected format and ensure integer values
                    IFS=',' read -r r g b <<< "$color_part"
                    r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                    g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                    b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                    if [ "$format" = "rgb" ]; then
                        # Display RGB format with visual preview
                        printf "\\033[48;2;%s;%s;%sm    \\033[0m %s,%s,%s (%s%%)\\n" "$r_int" "$g_int" "$b_int" "$r_int" "$g_int" "$b_int" "$percentage"
                    else
                        # Display hex format with visual preview
                        hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")
                        printf "\\033[48;2;%s;%s;%sm    \\033[0m %s (%s%%)\\n" "$r_int" "$g_int" "$b_int" "$hex_color" "$percentage"
                    fi
                fi
            done

            # Clean up temp file
            rm -f "$temp_vibrance_file"
        else
            # For non-preview mode, always show brightness and colors with percentages
            brightness_value=$(_get_brightness "${image}")
            brightness_category=$(_categorize_brightness "${brightness_value}" "${image}")

            # Output brightness mode and colors sorted by percentage for piping to other scripts
            printf "BRIGHTNESS:%s\\n" "${brightness_category}"
            _quantize_colors "${image}" "${num_colors}" "${format}" "${sort}" ""  # Always show percentages, no brightness header
        fi
    else
        if [ -z "${quiet}" ]; then
            printf "%s\\n" "Warning: '${image}' doesn't exist, skipping..." >&2
        fi
        _false
    fi
done
