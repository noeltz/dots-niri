#!/bin/sh
#description: find dominant colors in images
#usage: n0_image_analyzer image-file

#example: n0_image_analyzer black-and-white-image.png
#output 3 dominant colors in rgb format
#191,191,191
#80,80,80
#185,185,185

PROGNAME="$(expr "${0}" : '.*/\([^/]*\)')"

_usage() {
    printf "Usage: %s\\n" "${PROGNAME} [options] image-file ..."
    printf "%s\\n" "Find dominant colors in images."
    printf "\\n"
    printf "%s\\n" "  -d, --deviation   deviation, higher value, faster computation, default 1"
    printf "%s\\n" "  -k, --kmeans      output colors (using quantization), default 3"
    printf "%s\\n" "  -r, --resize      resize before procedure, lower value, faster computation, default 250x250"
    printf "%s\\n" "  -f, --format      output format [rgb|hex], default rgb"
    printf "%s\\n" "  -p, --preview     preview colors in command line"
    printf "%s\\n" "  -P, --percent     show color percentages"
    printf "%s\\n" "  -b, --brightness  show image brightness information"
    printf "%s\\n" "  -q, --quiet       suppress warnings"
    printf "%s\\n" "  --version         show version information and exit"
    printf "%s\\n" "  -h, --help        show this help message and exit"
}

_die() {
    [ -z "${1}" ] || printf "%s\\n" "${*}" >&2
    _usage >&2; exit 1
}

_is_int() {
    #look for an integer, returns 0 on success, 1 otherwise
    #http://www.unix.com/shell-programming-and-scripting/172070-help-scripting-command.html
    case "${1}" in
        *[!0-9]*|"") return 1 ;;
    esac
}

_is_resize_format() {
    # Check if resize format is valid (e.g., 25x25)
    case "${1}" in
        *[!0-9x]*|"") return 1 ;;  # Contains non-digit, non-x characters or empty
        *x*) : ;;  # Contains 'x'
        *) return 1 ;;
    esac
}

_validate_image() {
    local image="$1"
    if [ ! -f "${image}" ]; then
        printf "%s\\n" "Error: '${image}' doesn't exist" >&2
        return 1
    fi

    # Check if ImageMagick can read the file
    if ! convert "${image}" -format "" info: >/dev/null 2>&1; then
        printf "%s\\n" "Error: '${image}' is not a supported image format" >&2
        return 1
    fi
}

_quantize_colors() {
    # Function to find dominant colors using ImageMagick's quantization
    # This is more effective for preserving diverse colors than k-means on histogram
    local image="$1"
    local num_colors="$2"
    local format="$3"
    local show_percent="$4"
    local brightness_requested="$5"

    # Show brightness information if requested
    if [ -n "${brightness_requested}" ]; then
        brightness_value=$(_get_brightness "${image}")
        brightness_category=$(_categorize_brightness "${brightness_value}" "${image}")
        printf "Image brightness: %s/255 (%s)\\n" "${brightness_value}" "${brightness_category}"
        printf "─────────────────────────────────────────────────────\\n"
    fi

    # Use ImageMagick's quantization to reduce colors to the specified number
    # First resize the image to a reasonable size (similar to what dominantcolor does)
    # Then apply color quantization
    colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
        -format "%c" histogram:info: 2>/dev/null | \
        awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
        sort -t, -k1,1nr)

    # Process the output to extract color counts and convert to required format
    echo "$colors_output" | while IFS= read -r line; do
        if [ -n "$line" ]; then
            # Extract total pixel count and color
            total_pixels=$(echo "$line" | cut -d: -f1)
            color_part=$(echo "$line" | cut -d: -f2-)

            if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                # Calculate percentage if needed
                if [ "$show_percent" = "1" ]; then
                    # For relative percentages within the quantized result
                    # We need to calculate based on the total pixels in the quantized image
                    # Get the total pixels in the resized image
                    resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                    if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                        percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.4f", ($1*100.0)/$2}')
                    else
                        percentage="0.0000"
                    fi

                    if [ "$format" = "rgb" ]; then
                        echo "$color_part,$percentage"
                    else
                        # Convert RGB to hex
                        IFS=',' read -r r g b <<< "$color_part"
                        # Ensure values are valid and convert to integers for hex formatting
                        # Use awk for safer number handling
                        r=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b=$(echo "$b" | awk '{printf "%.0f", $1}')
                        hex_color=$(printf "#%02X%02X%02X" "$r" "$g" "$b")
                        echo "$hex_color ($percentage%)"
                    fi
                else
                    if [ "$format" = "rgb" ]; then
                        echo "$color_part"
                    else
                        # Convert RGB to hex
                        IFS=',' read -r r g b <<< "$color_part"
                        # Ensure values are valid and convert to integers for hex formatting
                        # Use awk for safer number handling
                        r=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b=$(echo "$b" | awk '{printf "%.0f", $1}')
                        printf "#%02X%02X%02X\\n" "$r" "$g" "$b"
                    fi
                fi
            fi
        fi
    done
}

_get_brightness_by_dominant_colors() {
    # Function to calculate brightness based on dominant colors
    # Uses quantization to get dominant colors and analyzes their brightness
    # When using only 2 colors, focuses on the most dominant one
    local image="$1"
    local num_colors="${2:-8}"  # Default to 8 dominant colors, caller can specify more

    # Use ImageMagick's quantization to get dominant colors
    dominant_colors=$(convert "${image}" -resize 100x100! -depth 8 +dither -colors "$num_colors" \
        -format "%c" histogram:info: 2>/dev/null)

    if [ -n "$dominant_colors" ]; then
        if [ "$num_colors" -le 2 ]; then
            # When using only 2 colors, get the brightness of the most dominant one
            brightness_result=$(echo "$dominant_colors" | awk '
            {
                # Split the line to get the count and RGB values
                # Format: "COUNT: (R,G,B) #HEX srgb(...)"
                colon_pos = index($0, ":");
                if (colon_pos > 0) {
                    count = substr($0, 1, colon_pos-1);

                    # Extract RGB values from "(R,G,B)" format
                    paren_start = index($0, "(");
                    paren_end = index($0, ")");
                    if (paren_start > 0 && paren_end > paren_start) {
                        rgb_str = substr($0, paren_start+1, paren_end-paren_start-1);
                        split(rgb_str, rgb_vals, ",");
                        red = rgb_vals[1];
                        green = rgb_vals[2];
                        blue = rgb_vals[3];

                        # Calculate luminance using standard formula: 0.299*R + 0.587*G + 0.114*B
                        luminance = 0.299 * red + 0.587 * green + 0.114 * blue;

                        # Store count and luminance
                        color_counts[NR] = count;
                        color_luminances[NR] = luminance;

                        # Keep track of the most dominant color index
                        if (count > max_count) {
                            max_count = count;
                            most_dominant_idx = NR;
                        }
                    }
                }
            }
            END {
                if (most_dominant_idx != "") {
                    # Return luminance of the most dominant color
                    printf "%.0f", color_luminances[most_dominant_idx];
                } else {
                    print 128; # Default if no dominant color found
                }
            }')
        else
            # For more than 2 colors, use weighted average (original behavior)
            brightness_result=$(echo "$dominant_colors" | awk '
            {
                # Split the line to get the count and RGB values
                # Format: "COUNT: (R,G,B) #HEX srgb(...)"
                colon_pos = index($0, ":");
                if (colon_pos > 0) {
                    count = substr($0, 1, colon_pos-1);

                    # Extract RGB values from "(R,G,B)" format
                    paren_start = index($0, "(");
                    paren_end = index($0, ")");
                    if (paren_start > 0 && paren_end > paren_start) {
                        rgb_str = substr($0, paren_start+1, paren_end-paren_start-1);
                        split(rgb_str, rgb_vals, ",");
                        red = rgb_vals[1];
                        green = rgb_vals[2];
                        blue = rgb_vals[3];

                        # Calculate luminance using standard formula: 0.299*R + 0.587*G + 0.114*B
                        luminance = 0.299 * red + 0.587 * green + 0.114 * blue;

                        total_luminance += luminance * count;
                        total_count += count;
                    }
                }
            }
            END {
                if (total_count > 0) {
                    avg_brightness = total_luminance / total_count;
                    printf "%.0f", avg_brightness;
                } else {
                    print 128; # Default if no dominant colors found
                }
            }')
        fi

        if [ -n "$brightness_result" ]; then
            printf "%s" "$brightness_result"
            return
        fi
    fi

    # Fallback: if dominant color analysis fails, use original method
    avg_brightness=$(convert "${image}" -colorspace Gray -resize 1x1 -format "%[fx:255*u]" info:- 2>/dev/null)
    if [ -n "$avg_brightness" ]; then
        avg_brightness=$(echo "$avg_brightness" | awk '{if(NF>0) printf "%.0f", $1; else print "128"}')
        printf "%s" "$avg_brightness"
    else
        printf "128"
    fi
}

_get_brightness() {
    # Function to calculate brightness based on top 2 dominant colors (main entry point)
    local image="$1"

    # Use dominant color analysis with top 2 colors only, based on the most prominent one
    _get_brightness_by_dominant_colors "$image" "2"
}

_categorize_brightness() {
    # Function to determine if image is dark or light based on dominant color analysis
    # With dominant colors, we might want a different threshold than for average brightness
    local brightness="$1"
    local image="$2"  # Optional: Pass image path to potentially get more dominant colors

    # Use a more appropriate threshold for dominant color based brightness
    # Since dominant colors represent the most significant visual elements,
    # a threshold around 128-135 might be more appropriate
    if [ "$brightness" -lt 135 ]; then
        printf "dark"
    else
        printf "light"
    fi
}

_display_color_preview() {
    # Function to display color preview using ANSI escape codes
    local color="$1"
    local format="$2"

    if [ "$format" = "hex" ]; then
        # Convert hex to RGB for ANSI codes if needed, but for now we'll use the color as provided
        # Extract RGB values from hex for ANSI code
        if [ ${#color} -eq 7 ] && [ "${color#?}" != "$color" ]; then
            # Remove # and extract RGB values
            hex_color="${color#'#'}"
            r=$(printf "%d" 0x${hex_color:0:2})
            g=$(printf "%d" 0x${hex_color:2:2})
            b=$(printf "%d" 0x${hex_color:4:2})
        fi
    else
        # Assuming RGB format: r,g,b
        old_IFS="$IFS"
        IFS=',' read -r r g b << EOF
$color
EOF
        IFS="$old_IFS"
    fi

    # Ensure values are valid and convert to integers for ANSI escape sequence
    # Use awk for safer number handling
    r=$(echo "$r" | awk '{printf "%.0f", $1}')
    g=$(echo "$g" | awk '{printf "%.0f", $1}')
    b=$(echo "$b" | awk '{printf "%.0f", $1}')

    # ANSI escape code for background color
    printf "\\033[48;2;%s;%s;%sm    \\033[0m %s\\n" "$r" "$g" "$b" "$color"
}

_preview_colors() {
    # Function to preview colors in the command line
    awk_prog_preview='
    function _euclidean(p1,p2) {
        split(p1, p1_coordinates, ",")
        split(p2, p2_coordinates, ",")
        _euclidean__distance=0
        for (coordinate=1; coordinate <= 3; coordinate++) {
                        #skip alpha channels
            remains=p1_coordinates[coordinate] - p2_coordinates[coordinate]
            _euclidean__distance+=remains * remains
            #_euclidean__distance+=remains^2 #doesnt work on ubuntu busybox awk
        }
        return _euclidean__distance
    }

    function _calculate_center(plist) {
        split(plist, plist_array)
        count=0; sumX=0; sumY=0; sumZ=0;
        for (point in plist_array) {
            split(plist_array[point], coordinates, ",")
            for (coordinate in coordinates) {
                if (coordinate == 1) {
                    split(coordinates[coordinate], composed_coordinate, ":")
                    times=composed_coordinate[1]
                    coordinateX=composed_coordinate[2]
                    count+=times
                    sumX+=coordinateX*times
                }
                else if (coordinate == 2) sumY+=coordinates[coordinate] * times
                else if (coordinate == 3) sumZ+=coordinates[coordinate] * times
            }
        }

        //avoid division by zero
        if(count) {
            sumX=int(sumX/count)
            sumY=int(sumY/count)
            sumZ=int(sumZ/count)
        }
        return sumX "," sumY "," sumZ
    }

    function _max(value1, value2) {
        if (value1 > value2) return value1
        else return value2
    }

    function _randint(n) { return 1 + int(rand() * n) }

    { points_times=points_times $0 " " }

    END {
        #print points_times
        points=points_times
        #remove time field to improve computation performance
        gsub(/[0-9]?[0-9]?[0-9]?[0-9]?[0-9]?[0-9]?:/,"", points)

        points_times_array_len=split(points_times, points_times_array)
        split(points, points_array)

        #use deterministic initialization - use first k points as initial centers
        # This ensures consistent results across runs
        for (i = 1; i <= kmeans && i <= points_times_array_len; i++) {
            clusters_array[i]=points_array[i]
            #print clusters_array[i]
        }

        # If there are fewer points than requested kmeans, duplicate the last point
        for (i = points_times_array_len + 1; i <= kmeans; i++) {
            clusters_array[i]=points_array[points_times_array_len]
        }

        while (1) {
            total_points = 0
            for (p in points_array) {
                total_points++
                distance=0; for (i = 1; i<= kmeans; i++) {
                    distance = _euclidean(points_array[p], clusters_array[i])
                    if (i == 1) { smallest_distance=distance; idx=1 }
                    else if (distance < smallest_distance) {
                        smallest_distance=distance
                        idx=i
                    }
                    #print points_array[p] " " clusters_array[i] " " distance " " smallest_distance
                }
                plists[idx]=plists[idx] points_times_array[p] " "
                assignments[p] = idx  # Track which cluster each point is assigned to
                #print idx
                #print "============"
            }

            #print plists[1]
            #print "======================"
            #print plists[2]
            #print "======================"
            #print plists[3]
            #print "======================"
            #print plists[4]
            #print "======================"

            diff = 0; for (item in clusters_array) old_clusters_array[item]=clusters_array[item]
            for (c in clusters_array) {
                clusters_array[c] = _calculate_center(plists[c])
                diff = _max(diff, _euclidean(old_clusters_array[c], clusters_array[c]))
            }

            #if (1) break
            if (diff < deviation) {
                # Count number of points in each cluster for percentage calculation
                for (a in assignments) {
                    cluster_counts[assignments[a]]++
                }

                # Collect results and calculate percentages
                result_idx = 0
                for (c in clusters_array) {
                    cluster_count = cluster_counts[c]
                    if (cluster_count == "") cluster_count = 0
                    percentage = (total_points > 0) ? (cluster_count * 100.0 / total_points) : 0

                    # Store RGB color and percentage for sorting
                    rgb_results[result_idx] = clusters_array[c]
                    percent_results[result_idx] = percentage
                    result_idx++
                }

                # Merge similar colors to reduce visually redundant colors
                # Use a threshold of 30 for RGB Euclidean distance (out of possible 442 max)
                n = result_idx
                merged = 0

                # Convert all colors to RGB components for distance calculation
                for (i = 0; i < n; i++) {
                    split(rgb_results[i], rgb, ",")
                    r[i] = rgb[1]
                    g[i] = rgb[2]
                    b[i] = rgb[3]
                }

                # Compare each color with every other color
                for (i = 0; i < n - 1; i++) {
                    if (r[i] == "") continue  # Skip if already merged
                    for (j = i + 1; j < n; j++) {
                        if (r[j] == "") continue  # Skip if already merged

                        # Calculate Euclidean distance in RGB space
                        dr = r[i] - r[j]
                        dg = g[i] - g[j]
                        db = b[i] - b[j]
                        distance = sqrt(dr*dr + dg*dg + db*db)

                        # Merge if colors are visually similar (threshold = 30)
                        if (distance < 30) {
                            # Calculate weighted average of colors based on their percentages
                            total_percent = percent_results[i] + percent_results[j]
                            new_r = int((r[i] * percent_results[i] + r[j] * percent_results[j]) / total_percent)
                            new_g = int((g[i] * percent_results[i] + g[j] * percent_results[j]) / total_percent)
                            new_b = int((b[i] * percent_results[i] + b[j] * percent_results[j]) / total_percent)

                            # Update first color with merged result
                            rgb_results[i] = new_r "," new_g "," new_b
                            r[i] = new_r
                            g[i] = new_g
                            b[i] = new_b
                            percent_results[i] = percent_results[i] + percent_results[j]

                            # Mark second color as merged by clearing it
                            r[j] = ""
                            g[j] = ""
                            b[j] = ""
                            rgb_results[j] = ""

                            merged = 1
                        }
                    }
                }

                # Create new result array without merged/empty slots
                final_idx = 0
                for (i = 0; i < n; i++) {
                    if (r[i] != "") {
                        final_colors[final_idx] = rgb_results[i]
                        final_percents[final_idx] = percent_results[i]
                        final_idx++
                    }
                }

                # Sort by percentage in descending order using simple bubble sort
                n_final = final_idx
                for (i = 0; i < n_final-1; i++) {
                    for (j = 0; j < n_final-i-1; j++) {
                        if (final_percents[j] < final_percents[j+1]) {
                            # Swap percentages
                            temp_percent = final_percents[j]
                            final_percents[j] = final_percents[j+1]
                            final_percents[j+1] = temp_percent

                            # Swap corresponding colors
                            temp_color = final_colors[j]
                            final_colors[j] = final_colors[j+1]
                            final_colors[j+1] = temp_color
                        }
                    }
                }

                # Output sorted results with both RGB and hex
                for (i = 0; i < n_final; i++) {
                    # Output RGB
                    print final_colors[i]
                    # Convert RGB to hex
                    split(final_colors[i], cluster, ",")
                    printf "#"
                    for (coordinate in cluster) printf "%02X", cluster[coordinate]
                    printf " (%.2f%%)", final_percents[i]
                    print ""
                }
                break
            }
        }
    }'

    for image; do
        if _validate_image "${image}"; then
            # Show brightness information if requested
            if [ -n "${brightness}" ]; then
                brightness_value=$(_get_brightness "${image}")
                brightness_category=$(_categorize_brightness "${brightness_value}" "${image}")
                printf "Image brightness: %s/255 (%s)\\n" "${brightness_value}" "${brightness_category}"
                printf "─────────────────────────────────────────────────────\\n"
            fi

            image_points_times="$(convert "${image}" -resize "${resize}" \
                -colorspace RGB -depth 8 -format %c histogram:info:- 2>/dev/null |   \
                ${awk_bin} \
                'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}')"

            # Check if we got any color data
            if [ -z "${image_points_times}" ]; then
                if [ -z "${quiet}" ]; then
                    printf "%s\\n" "Warning: No color data extracted from '${image}'" >&2
                fi
                _false
                continue
            fi

            # Get colors from the algorithm
            colors_output=$(printf "%s" "${image_points_times}" | ${awk_bin}      \
                -v kmeans="${kmeans}" -v deviation="${deviation}" \
                -v format="rgb" "${awk_prog_preview}")

            # Display preview
            printf "\\nColor preview for %s:\\n" "${image}"
            if [ -n "${brightness}" ]; then
                printf "%s\\n" "─────────────────────────────────────────────────────"
            else
                printf "%s\\n" "─────────────────────────────────────────────────────"
            fi

            # Store colors with percentages to sort by percentage
            # Create a temporary file to store sorted data
            temp_file=$(mktemp)
            echo "$colors_output" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    if [ "${line#'#'}" != "$line" ]; then
                        # This is a hex color (starts with #)
                        # Extract hex and percentage
                        if echo "$line" | grep -q " ("; then
                            hex_color=$(echo "$line" | cut -d' ' -f1)
                            percentage=$(echo "$line" | sed 's/.*(\(.*\))$/\1/')
                            # Store as percentage:hex_color for sorting
                            echo "$percentage:$hex_color" >> "$temp_file"
                        else
                            hex_color="$line"
                            echo "0:$hex_color" >> "$temp_file"
                        fi
                    else
                        # This might be RGB, store separately but we'll handle in the hex processing
                        continue  # Skip RGB lines for now, we'll process hex with percentage
                    fi
                fi
            done

            # Process and display each color sorted by percentage (descending)
            if [ -f "$temp_file" ]; then
                # Sort percentages in descending order and display
                sort -t: -k1,1nr "$temp_file" | while IFS=: read -r percentage hex_color; do
                    if [ -n "$percentage" ] && [ -n "$hex_color" ]; then
                        # Convert hex to rgb for display
                        hex_clean="${hex_color#'#'}"
                        r=$(printf "%d" 0x${hex_clean:0:2})
                        g=$(printf "%d" 0x${hex_clean:2:2})
                        b=$(printf "%d" 0x${hex_clean:4:2})

                        # Display with ANSI color background
                        if [ -n "$percentage" ] && [ "$percentage" != "0" ]; then
                            printf "\\033[48;2;%s;%s;%sm    \\033[0m Hex: %s (%s%%)\\n" "$r" "$g" "$b" "$hex_color" "$percentage"
                        else
                            printf "\\033[48;2;%s;%s;%sm    \\033[0m Hex: %s\\n" "$r" "$g" "$b" "$hex_color"
                        fi
                    fi
                done
                rm -f "$temp_file"
            fi
        else
            if [ -z "${quiet}" ]; then
                printf "%s\\n" "Warning: '${image}' doesn't exist, skipping..." >&2
            fi
            _false
        fi
    done
}

_false() {
    return 1
}

_kmeans_awk() {
    awk_prog_base='
    function _euclidean(p1,p2) {
        split(p1, p1_coordinates, ",")
        split(p2, p2_coordinates, ",")
        _euclidean__distance=0
        for (coordinate=1; coordinate <= 3; coordinate++) {
                        #skip alpha channels
            remains=p1_coordinates[coordinate] - p2_coordinates[coordinate]
            _euclidean__distance+=remains * remains
            #_euclidean__distance+=remains^2 #doesnt work on ubuntu busybox awk
        }
        return _euclidean__distance
    }

    function _calculate_center(plist) {
        split(plist, plist_array)
        count=0; sumX=0; sumY=0; sumZ=0;
        for (point in plist_array) {
            split(plist_array[point], coordinates, ",")
            for (coordinate in coordinates) {
                if (coordinate == 1) {
                    split(coordinates[coordinate], composed_coordinate, ":")
                    times=composed_coordinate[1]
                    coordinateX=composed_coordinate[2]
                    count+=times
                    sumX+=coordinateX*times
                }
                else if (coordinate == 2) sumY+=coordinates[coordinate] * times
                else if (coordinate == 3) sumZ+=coordinates[coordinate] * times
            }
        }

        //avoid division by zero
        if(count) {
            sumX=int(sumX/count)
            sumY=int(sumY/count)
            sumZ=int(sumZ/count)
        }
        return sumX "," sumY "," sumZ
    }

    function _max(value1, value2) {
        if (value1 > value2) return value1
        else return value2
    }

    function _randint(n) { return 1 + int(rand() * n) }

    { points_times=points_times $0 " " }

    END {
        #print points_times
        points=points_times
        #remove time field to improve computation performance
        gsub(/[0-9]?[0-9]?[0-9]?[0-9]?[0-9]?[0-9]?:/,"", points)

        points_times_array_len=split(points_times, points_times_array)
        split(points, points_array)

        #use deterministic initialization - use first k points as initial centers
        # This ensures consistent results across runs
        for (i = 1; i <= kmeans && i <= points_times_array_len; i++) {
            clusters_array[i]=points_array[i]
            #print clusters_array[i]
        }

        # If there are fewer points than requested kmeans, duplicate the last point
        for (i = points_times_array_len + 1; i <= kmeans; i++) {
            clusters_array[i]=points_array[points_times_array_len]
        }

        while (1) {
            total_points = 0
            for (p in points_array) {
                total_points++
                distance=0; for (i = 1; i<= kmeans; i++) {
                    distance = _euclidean(points_array[p], clusters_array[i])
                    if (i == 1) { smallest_distance=distance; idx=1 }
                    else if (distance < smallest_distance) {
                        smallest_distance=distance
                        idx=i
                    }
                    #print points_array[p] " " clusters_array[i] " " distance " " smallest_distance
                }
                plists[idx]=plists[idx] points_times_array[p] " "
                assignments[p] = idx  # Track which cluster each point is assigned to
                #print idx
                #print "============"
            }

            #print plists[1]
            #print "======================"
            #print plists[2]
            #print "======================"
            #print plists[3]
            #print "======================"
            #print plists[4]
            #print "======================"

            diff = 0; for (item in clusters_array) old_clusters_array[item]=clusters_array[item]
            for (c in clusters_array) {
                clusters_array[c] = _calculate_center(plists[c])
                diff = _max(diff, _euclidean(old_clusters_array[c], clusters_array[c]))
            }

            #if (1) break
            if (diff < deviation) {
                # Count number of points in each cluster
                for (a in assignments) {
                    cluster_counts[assignments[a]]++
                }

                # Collect results and calculate percentages
                result_idx = 0
                for (c in clusters_array) {
                    cluster_count = cluster_counts[c]
                    if (cluster_count == "") cluster_count = 0
                    percentage = (total_points > 0) ? (cluster_count * 100.0 / total_points) : 0

                    # Store clusters and their percentages
                    color_results[result_idx] = clusters_array[c]
                    percent_results[result_idx] = percentage
                    result_idx++
                }

                # Merge similar colors to reduce visually redundant colors
                # Use a threshold of 60 for RGB Euclidean distance (out of possible 442 max)
                # Only merge if distance < 60 (less aggressive than before)
                n = result_idx
                merged = 0

                # Convert all colors to RGB components for distance calculation
                for (i = 0; i < n; i++) {
                    split(color_results[i], rgb, ",")
                    r[i] = rgb[1]
                    g[i] = rgb[2]
                    b[i] = rgb[3]
                }

                # Compare each color with every other color
                for (i = 0; i < n - 1; i++) {
                    if (r[i] == "") continue  # Skip if already merged
                    for (j = i + 1; j < n; j++) {
                        if (r[j] == "") continue  # Skip if already merged

                        # Calculate Euclidean distance in RGB space
                        dr = r[i] - r[j]
                        dg = g[i] - g[j]
                        db = b[i] - b[j]
                        distance = sqrt(dr*dr + dg*dg + db*db)

                        # Calculate brightness difference using luminance formula
                        # Luminance = 0.299*R + 0.587*G + 0.114*B
                        lum1 = 0.299 * r[i] + 0.587 * g[i] + 0.114 * b[i]
                        lum2 = 0.299 * r[j] + 0.587 * g[j] + 0.114 * b[j]
                        brightness_diff = (lum1 > lum2) ? (lum1 - lum2) : (lum2 - lum1)

                        # Calculate saturation as a measure of colorfulness
                        max_val = (r[i] > g[i]) ? r[i] : g[i]; max_val = (max_val > b[i]) ? max_val : b[i]
                        min_val = (r[i] < g[i]) ? r[i] : g[i]; min_val = (min_val < b[i]) ? min_val : b[i]
                        sat1 = (max_val == 0) ? 0 : (max_val - min_val) * 100 / max_val

                        max_val = (r[j] > g[j]) ? r[j] : g[j]; max_val = (max_val > b[j]) ? max_val : b[j]
                        min_val = (r[j] < g[j]) ? r[j] : g[j]; min_val = (min_val < b[j]) ? min_val : b[j]
                        sat2 = (max_val == 0) ? 0 : (max_val - min_val) * 100 / max_val

                        saturation_diff = (sat1 > sat2) ? (sat1 - sat2) : (sat2 - sat1)

                        # Merge if colors are visually similar AND brightness/saturation difference is not too large
                        # Use combined criteria to better preserve visually distinct colors
                        if (distance < 60 && brightness_diff <= 80 && saturation_diff <= 30) {
                            # Only merge if colors are similar in color, brightness, and saturation
                            # Calculate weighted average of colors based on their percentages
                            total_percent = percent_results[i] + percent_results[j]
                            new_r = int((r[i] * percent_results[i] + r[j] * percent_results[j]) / total_percent)
                            new_g = int((g[i] * percent_results[i] + g[j] * percent_results[j]) / total_percent)
                            new_b = int((b[i] * percent_results[i] + b[j] * percent_results[j]) / total_percent)

                            # Update first color with merged result
                            color_results[i] = new_r "," new_g "," new_b
                            r[i] = new_r
                            g[i] = new_g
                            b[i] = new_b
                            percent_results[i] = percent_results[i] + percent_results[j]

                            # Mark second color as merged by clearing it
                            r[j] = ""
                            g[j] = ""
                            b[j] = ""
                            color_results[j] = ""

                            merged = 1
                        }
                    }
                }

                # Create new result array without merged/empty slots
                final_idx = 0
                for (i = 0; i < n; i++) {
                    if (r[i] != "") {
                        final_colors[final_idx] = color_results[i]
                        final_percents[final_idx] = percent_results[i]
                        final_idx++
                    }
                }

                # Sort by percentage in descending order using simple bubble sort
                n_final = final_idx
                for (i = 0; i < n_final-1; i++) {
                    for (j = 0; j < n_final-i-1; j++) {
                        if (final_percents[j] < final_percents[j+1]) {
                            # Swap percentages
                            temp_percent = final_percents[j]
                            final_percents[j] = final_percents[j+1]
                            final_percents[j+1] = temp_percent

                            # Swap corresponding colors
                            temp_color = final_colors[j]
                            final_colors[j] = final_colors[j+1]
                            final_colors[j+1] = temp_color
                        }
                    }
                }

                # Output sorted results
                for (i = 0; i < n_final; i++) {
                    if (show_percent == "1") {
                        if (format == "rgb") {
                            print final_colors[i] "," final_percents[i]
                        } else {
                            split(final_colors[i], cluster, ",")
                            for (coordinate in cluster) printf "%02X", cluster[coordinate]
                            printf " (%.2f%%)", final_percents[i]
                            print ""
                        }
                    } else {
                        if (format == "rgb") {
                            print final_colors[i]
                        } else {
                            split(final_colors[i], cluster, ",")
                            printf "#"
                            for (coordinate in cluster) printf "%02X", cluster[coordinate]
                            print ""
                        }
                    }
                }
                break
            }
        }
    }'

    for image; do
        if _validate_image "${image}"; then
            # Show brightness information if requested
            if [ -n "${brightness}" ]; then
                brightness_value=$(_get_brightness "${image}")
                brightness_category=$(_categorize_brightness "${brightness_value}" "${image}")
                printf "Image brightness: %s/255 (%s)\\n" "${brightness_value}" "${brightness_category}"
                printf "─────────────────────────────────────────────────────\\n"
            fi

            image_points_times="$(convert "${image}" -resize "${resize}" \
                -colorspace RGB -depth 8 -format %c histogram:info:- 2>/dev/null |   \
                ${awk_bin} \
                'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}')"

            # Check if we got any color data
            if [ -z "${image_points_times}" ]; then
                if [ -z "${quiet}" ]; then
                    printf "%s\\n" "Warning: No color data extracted from '${image}'" >&2
                fi
                _false
                continue
            fi

            # Determine if we need to show percentages
            if [ -n "${percent}" ]; then
                show_percent="1"
            else
                show_percent="0"
            fi

            printf "%s" "${image_points_times}" | ${awk_bin}      \
                -v kmeans="${kmeans}" -v deviation="${deviation}" \
                -v format="${format}" -v show_percent="${show_percent}" "${awk_prog_base}"
        else
            if [ -z "${quiet}" ]; then
                printf "%s\\n" "Warning: '${image}' doesn't exist, skipping..." >&2
            fi
            _false
        fi
    done
}

_check_deps() {
    if command -v "awk" >/dev/null 2>&1; then
        awk_bin="awk"
    elif busybox awk 1 /dev/null >/dev/null 2>&1; then
        awk_bin="busybox awk"
    else
        printf "%s\\n" "Error: 'awk' is required to run this program. Please install gawk or mawk." >&2
        exit 1
    fi

    if ! command -v "convert" >/dev/null 2>&1; then
        printf "%s\\n" "Error: 'convert' (ImageMagick) is required to run this program. Please install ImageMagick." >&2
        exit 1
    fi
}

_sanitize_parameters(){
    if [ -z "${kmeans}" ]; then
        kmeans="3"
    else
        _is_int "${kmeans}" || _die "Option -k|--kmeans requires a number parameter '${kmeans}'"
    fi

    if [ -z "${deviation}" ]; then
        deviation="1"
    else
        _is_int "${deviation}" || _die "Option -d|--deviation requires a number parameter '${deviation}'"
    fi

    if [ -z "${format}" ]; then
        format="rgb"
    else
        case "${format}" in
            rgb|hex) : ;;
            *) _die "Output valid formats are rgb|hex: '${format}'" ;;
        esac
    fi

    if [ -z "${resize}" ]; then
        resize="25x25"
    else
        _is_resize_format "${resize}" || _die "Option -r|--resize requires a format like '25x25': '${resize}'"
    fi
}

# Initialize preview, percent, brightness, and method flags
preview=""
percent=""
brightness=""
method="quantize"  # Default to quantize for better results
resize="250x250"   # Default to larger resize for better color detection

if [ ! -t 0 ]; then
    #there is input comming from pipe or file, add to the end of $@
    set -- "${@}" $(cat)
fi

for arg in "${@}"; do #parse options
    case "${arg}" in
        --version) printf "%s %s\\n" "${PROGNAME}" "1.1"; exit ;;
        -h|--help) _usage && exit ;;
        '-p'|'--preview') preview="1"; shift ;;
        '-P'|'--percent') percent="1"; shift ;;
        '-b'|'--brightness') brightness="1"; shift ;;
        '-q'|'--quiet') quiet="1"; shift ;;
        '-d'|'--deviation')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; deviation="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -d*) deviation="${1#-d}"; shift ;;
        --deviation*) deviation="${1#--deviation}"; shift ;;
        '-k'|'--kmeans')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; kmeans="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -k*) kmeans="${1#-k}"; shift ;;
        --kmeans*) kmeans="${1#--kmeans}"; shift ;;
        '-r'|'--resize')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; resize="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -r*) resize="${1#-r}"; shift ;;
        --resize*) resize="${1#--resize}"; shift ;;
        '-f'|'--format')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; format="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -f*) format="${1#-f}"; shift ;;
        --format*) format="${1#--format}"; shift ;;
        -*) _die "${PROGNAME}: unrecognized option '${arg}'" ;;
    esac
done

_check_deps && _sanitize_parameters && [ "${#}" -eq "0" ] && _die

# Use quantization method only (default method)
for image; do
    if _validate_image "${image}"; then
        # Determine if we need to show percentages (based on percent flag)
        if [ -n "${percent}" ]; then
            show_percent="1"
        else
            show_percent="0"
        fi

        if [ -n "${preview}" ]; then
            # Process for preview output
            # Show brightness information if requested
            if [ -n "${brightness}" ]; then
                brightness_value=$(_get_brightness "${image}")
                brightness_category=$(_categorize_brightness "${brightness_value}" "${image}")
                printf "Image brightness: %s/255 (%s)\\n" "${brightness_value}" "${brightness_category}"
                printf "─────────────────────────────────────────────────────\\n"
            fi

            # Use ImageMagick's quantization to reduce colors to the specified number
            colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${kmeans}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t, -k1,1nr)

            printf "\\nColor preview for %s:\\n" "${image}"
            printf "%s\\n" "─────────────────────────────────────────────────────"

            # Process the output to create preview
            echo "$colors_output" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract total pixel count and color
                    total_pixels=$(echo "$line" | cut -d: -f1)
                    color_part=$(echo "$line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage for display
                        resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.2f", ($1*100.0)/$2}')
                        else
                            percentage="0.00"
                        fi

                        # Convert RGB to hex for display and ensure integer values
                        IFS=',' read -r r g b <<< "$color_part"
                        r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b_int=$(echo "$b" | awk '{printf "%.0f", $1}')
                        hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")

                        # Display with ANSI color background
                        printf "\\033[48;2;%s;%s;%sm    \\033[0m Hex: %s (%s%%)\\n" "$r_int" "$g_int" "$b_int" "$hex_color" "$percentage"
                    fi
                fi
            done
        else
            _quantize_colors "${image}" "${kmeans}" "${format}" "${show_percent}" "${brightness}"
        fi
    else
        if [ -z "${quiet}" ]; then
            printf "%s\\n" "Warning: '${image}' doesn't exist, skipping..." >&2
        fi
        _false
    fi
done
