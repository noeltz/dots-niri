#!/bin/sh
#description: find dominant colors in images
#usage: n0_image_analyzer image-file

#example: n0_image_analyzer black-and-white-image.png
#output 3 dominant colors in rgb format
#191,191,191
#80,80,80
#185,185,185

PROGNAME="$(expr "${0}" : '.*/\([^/]*\)')"

_usage() {
    printf "Usage: %s\\n" "${PROGNAME} [options] image-file ..."
    printf "%s\\n" "Find dominant colors in images."
    printf "\\n"
    printf "%s\\n" "  -d, --deviation   deviation, higher value, faster computation, default 1"
    printf "%s\\n" "  -n, --numcolors   number of output colors (using quantization), default 16"
    printf "%s\\n" "  -r, --resize      resize before procedure, lower value, faster computation, default 250x250"
    printf "%s\\n" "  -f, --format      output format [rgb|hex], default hex"
    printf "%s\\n" "  -s, --sort        sort method [percentage|vibrance], default percentage"
    printf "%s\\n" "  -p, --preview     preview colors in command line"
    printf "%s\\n" "  -c, --colortheme  match colors against Colloid GTK theme palettes"
    printf "%s\\n" "  -q, --quiet       suppress warnings"
    printf "%s\\n" "  --version         show version information and exit"
    printf "%s\\n" "  -h, --help        show this help message and exit"
}

_die() {
    [ -z "${1}" ] || printf "%s\\n" "${*}" >&2
    _usage >&2; exit 1
}

_is_int() {
    #look for an integer, returns 0 on success, 1 otherwise
    #http://www.unix.com/shell-programming-and-scripting/172070-help-scripting-command.html
    case "${1}" in
        *[!0-9]*|"") return 1 ;;
    esac
}

_is_resize_format() {
    # Check if resize format is valid (e.g., 25x25)
    case "${1}" in
        *[!0-9x]*|"") return 1 ;;  # Contains non-digit, non-x characters or empty
        *x*) : ;;  # Contains 'x'
        *) return 1 ;;
    esac
}

_validate_image() {
    local image="$1"
    if [ ! -f "${image}" ]; then
        printf "%s\\n" "Error: '${image}' doesn't exist" >&2
        return 1
    fi

    # Check if ImageMagick can read the file
    if ! convert "${image}" -format "" info: >/dev/null 2>&1; then
        printf "%s\\n" "Error: '${image}' is not a supported image format" >&2
        return 1
    fi
}

_quantize_colors() {
    # Function to find dominant colors using ImageMagick's quantization
    # This is more effective for preserving diverse colors than k-means on histogram
    local image="$1"
    local num_colors="$2"
    local format="$3"
    local sort_method="$4"
    # Parameter 5 is no longer used since brightness is handled separately in main execution flow

    # Use ImageMagick's quantization to reduce colors to the specified number
    # First resize the image to a reasonable size (similar to what dominantcolor does)
    # Then apply color quantization
    colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
        -format "%c" histogram:info: 2>/dev/null | \
        awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
        sort -t, -k1,1nr)

    # Collect all color data with percentage and vibrance information (using pipe delimiter to avoid comma conflicts)
    temp_file=$(mktemp)
    temp_vibrance_file=$(mktemp)

    # Process the output to extract color counts and convert to required format
    echo "$colors_output" | while IFS= read -r line; do
        if [ -n "$line" ]; then
            # Extract total pixel count and color
            total_pixels=$(echo "$line" | cut -d: -f1)
            color_part=$(echo "$line" | cut -d: -f2-)

            if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                # Calculate percentage (always calculated and shown now)
                # For relative percentages within the quantized result
                # We need to calculate based on the total pixels in the quantized image
                # Get the total pixels in the resized image
                resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                    percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.6f", ($1*100.0)/$2}')
                else
                    percentage="0.000000"
                fi

                # Calculate vibrance based on saturation (max - min of RGB values)
                IFS=',' read -r r g b <<< "$color_part"
                # Ensure values are valid and convert to integers for vibrance calculation
                r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                # Calculate saturation as the difference between max and min RGB values
                # This will give us the vibrance value
                if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                    max_val="$r_int"
                elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                    max_val="$g_int"
                else
                    max_val="$b_int"
                fi

                if [ "$r_int" -le "$g_int" ] && [ "$r_int" -le "$b_int" ]; then
                    min_val="$r_int"
                elif [ "$g_int" -le "$r_int" ] && [ "$g_int" -le "$b_int" ]; then
                    min_val="$g_int"
                else
                    min_val="$b_int"
                fi

                vibrance=$((max_val - min_val))

                # Store data for sorting - format: "r_int|g_int|b_int|percentage|vibrance" for rgb, or "hex_color|percentage|vibrance" for hex
                if [ "$format" = "rgb" ]; then
                    echo "$r_int|$g_int|$b_int|$percentage|$vibrance" >> "$temp_vibrance_file"
                else
                    hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")
                    echo "$hex_color|$percentage|$vibrance" >> "$temp_vibrance_file"
                fi
            fi
        fi
    done

    # Wait for all background processes to complete
    wait

    # Sort based on the selected method
    if [ "$sort_method" = "vibrance" ]; then
        # Sort by vibrance (the last field, descending)
        if [ "$format" = "rgb" ]; then
            sort -t'|' -k5,5nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract RGB and percentage, excluding vibrance for output (first 4 fields)
                r_val=$(echo "$line" | cut -d'|' -f1)
                g_val=$(echo "$line" | cut -d'|' -f2)
                b_val=$(echo "$line" | cut -d'|' -f3)
                percentage=$(echo "$line" | cut -d'|' -f4)
                echo "$r_val,$g_val,$b_val,$percentage"
            done
        else
            sort -t'|' -k3,3nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract hex and percentage, excluding vibrance for output (first 2 fields)
                hex_color=$(echo "$line" | cut -d'|' -f1)
                percentage=$(echo "$line" | cut -d'|' -f2)
                echo "$hex_color ($percentage%)"
            done
        fi
    else
        # Sort by percentage (default behavior, descending)
        if [ "$format" = "rgb" ]; then
            sort -t'|' -k4,4nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract RGB and percentage, excluding vibrance for output (first 4 fields)
                r_val=$(echo "$line" | cut -d'|' -f1)
                g_val=$(echo "$line" | cut -d'|' -f2)
                b_val=$(echo "$line" | cut -d'|' -f3)
                percentage=$(echo "$line" | cut -d'|' -f4)
                echo "$r_val,$g_val,$b_val,$percentage"
            done
        else
            sort -t'|' -k2,2nr "$temp_vibrance_file" | while IFS= read -r line; do
                # Extract hex and percentage, excluding vibrance for output (first 2 fields)
                hex_color=$(echo "$line" | cut -d'|' -f1)
                percentage=$(echo "$line" | cut -d'|' -f2)
                echo "$hex_color ($percentage%)"
            done
        fi
    fi

    # Clean up temp files
    rm -f "$temp_file" "$temp_vibrance_file"
}

_get_brightness_by_dominant_colors() {
    # Function to calculate brightness based on dominant colors
    # Uses quantization to get dominant colors and analyzes their brightness
    # When using only 2 colors, focuses on the most dominant one
    local image="$1"
    local num_colors="${2:-8}"  # Default to 8 dominant colors, caller can specify more

    # Use ImageMagick's quantization to get dominant colors
    dominant_colors=$(convert "${image}" -resize 100x100! -depth 8 +dither -colors "$num_colors" \
        -format "%c" histogram:info: 2>/dev/null)

    if [ -n "$dominant_colors" ]; then
        if [ "$num_colors" -le 2 ]; then
            # When using only 2 colors, get the brightness of the most dominant one
            brightness_result=$(echo "$dominant_colors" | awk '
            {
                # Split the line to get the count and RGB values
                # Format: "COUNT: (R,G,B) #HEX srgb(...)"
                colon_pos = index($0, ":");
                if (colon_pos > 0) {
                    count = substr($0, 1, colon_pos-1);

                    # Extract RGB values from "(R,G,B)" format
                    paren_start = index($0, "(");
                    paren_end = index($0, ")");
                    if (paren_start > 0 && paren_end > paren_start) {
                        rgb_str = substr($0, paren_start+1, paren_end-paren_start-1);
                        split(rgb_str, rgb_vals, ",");
                        red = rgb_vals[1];
                        green = rgb_vals[2];
                        blue = rgb_vals[3];

                        # Calculate luminance using standard formula: 0.299*R + 0.587*G + 0.114*B
                        luminance = 0.299 * red + 0.587 * green + 0.114 * blue;

                        # Store count and luminance
                        color_counts[NR] = count;
                        color_luminances[NR] = luminance;

                        # Keep track of the most dominant color index
                        if (count > max_count) {
                            max_count = count;
                            most_dominant_idx = NR;
                        }
                    }
                }
            }
            END {
                if (most_dominant_idx != "") {
                    # Return luminance of the most dominant color
                    printf "%.0f", color_luminances[most_dominant_idx];
                } else {
                    print 128; # Default if no dominant color found
                }
            }')
        else
            # For more than 2 colors, use weighted average (original behavior)
            brightness_result=$(echo "$dominant_colors" | awk '
            {
                # Split the line to get the count and RGB values
                # Format: "COUNT: (R,G,B) #HEX srgb(...)"
                colon_pos = index($0, ":");
                if (colon_pos > 0) {
                    count = substr($0, 1, colon_pos-1);

                    # Extract RGB values from "(R,G,B)" format
                    paren_start = index($0, "(");
                    paren_end = index($0, ")");
                    if (paren_start > 0 && paren_end > paren_start) {
                        rgb_str = substr($0, paren_start+1, paren_end-paren_start-1);
                        split(rgb_str, rgb_vals, ",");
                        red = rgb_vals[1];
                        green = rgb_vals[2];
                        blue = rgb_vals[3];

                        # Calculate luminance using standard formula: 0.299*R + 0.587*G + 0.114*B
                        luminance = 0.299 * red + 0.587 * green + 0.114 * blue;

                        total_luminance += luminance * count;
                        total_count += count;
                    }
                }
            }
            END {
                if (total_count > 0) {
                    avg_brightness = total_luminance / total_count;
                    printf "%.0f", avg_brightness;
                } else {
                    print 128; # Default if no dominant colors found
                }
            }')
        fi

        if [ -n "$brightness_result" ]; then
            printf "%s" "$brightness_result"
            return
        fi
    fi

    # Fallback: if dominant color analysis fails, use original method
    avg_brightness=$(convert "${image}" -colorspace Gray -resize 1x1 -format "%[fx:255*u]" info:- 2>/dev/null)
    if [ -n "$avg_brightness" ]; then
        avg_brightness=$(echo "$avg_brightness" | awk '{if(NF>0) printf "%.0f", $1; else print "128"}')
        printf "%s" "$avg_brightness"
    else
        printf "128"
    fi
}

_get_brightness() {
    # Function to calculate brightness based on top 2 dominant colors (main entry point)
    local image="$1"

    # Use dominant color analysis with top 2 colors only, based on the most prominent one
    _get_brightness_by_dominant_colors "$image" "2"
}

_categorize_brightness_advanced() {
    # Function to determine if image is black, dark or light
    # Considers both overall brightness and dominant colors
    local image="$1"

    # Get dominant colors with their percentages
    # Use ImageMagick to quantize to a small number of colors to find dominant ones
    colors_output=$(convert "${image}" -resize 250x250 -depth 8 +dither -colors 5 -format "%c" histogram:info: 2>/dev/null | \
        awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
        sort -t: -k1,1nr -r)

    if [ -n "$colors_output" ]; then
        # Get the most dominant color (first line after sorting - highest count)
        first_line=$(echo "$colors_output" | head -n 1)
        if [ -n "$first_line" ]; then
            # Extract count and color
            total_pixels=$(echo "$first_line" | cut -d: -f1)
            color_part=$(echo "$first_line" | cut -d: -f2-)

            if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                # Calculate percentage of this dominant color
                all_pixels=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                if [ -n "$all_pixels" ] && [ "$all_pixels" -gt 0 ]; then
                    percentage=$(echo "$total_pixels $all_pixels" | awk '{printf "%.2f", ($1*100.0)/$2}')

                    # Check if this dominant color is very dark (almost black)
                    # Extract RGB components
                    IFS=',' read -r r g b <<< "$color_part"
                    r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                    g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                    b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                    # Find max RGB component to determine if color is very dark
                    if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                        max_component="$r_int"
                    elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                        max_component="$g_int"
                    else
                        max_component="$b_int"
                    fi

                    # If dominant color > 80% and the color is very dark (max component < 20), classify as black
                    # Use awk to do precise decimal comparison
                    is_over_80=$(echo "$percentage" | awk '
                    {
                        if ($1 > 80.0) print "yes"
                        else print "no"
                    }')

                    if [ "$is_over_80" = "yes" ] && [ "$max_component" -lt 20 ]; then
                        printf "black"
                        return
                    fi
                fi
            fi
        fi
    fi

    # If not classified as black, use traditional brightness categorization
    brightness_value=$(_get_brightness "${image}")
    if [ "$brightness_value" -lt 135 ]; then
        printf "dark"
    else
        printf "light"
    fi
}

_calculate_color_distance() {
    # Function to calculate RGB color distance between two hex colors
    local hex1="$1"
    local hex2="$2"

    # Remove # if present
    hex1="${hex1#'#'}"
    hex2="${hex2#'#'}"

    # Extract RGB components
    local r1=$(printf "%d" 0x${hex1:0:2})
    local g1=$(printf "%d" 0x${hex1:2:2})
    local b1=$(printf "%d" 0x${hex1:4:2})

    local r2=$(printf "%d" 0x${hex2:0:2})
    local g2=$(printf "%d" 0x${hex2:2:2})
    local b2=$(printf "%d" 0x${hex2:4:2})

    # Calculate Euclidean distance
    local dr=$((r1 - r2))
    local dg=$((g1 - g2))
    local db=$((b1 - b2))
    local distance=$(echo "$dr $dg $db" | awk '{result = sqrt($1*$1 + $2*$2 + $3*$3); printf "%.0f", result}')

    echo "$distance"
}

_load_color_palettes() {
    # Function to load all color palettes from SCSS files
    local scss_dir="$HOME/.repoinstalls/Colloid-gtk-theme/src/sass/"
    local temp_palette_file=$(mktemp)

    # Loop through all color palette files
    for scss_file in "${scss_dir}"_color-palette-*.scss; do
        if [ -f "$scss_file" ]; then
            # Extract variables from SCSS file with more flexible pattern matching
            # Allow for various spacing and formats including possible spaces, comments, etc.
            grep -E '\$[a-zA-Z0-9_-]+\s*:' "$scss_file" | while IFS= read -r line; do
                # Extract variable name and color with more flexible regex
                var_name=$(echo "$line" | sed -n 's/.*\(\$[a-zA-Z0-9_-]*\).*/\1/p' | xargs)

                # Extract hex color - match # followed by 3 or 6 hex digits, handling possible whitespace
                hex_color=$(echo "$line" | sed -n 's/.*#\([A-Fa-f0-9]\{3,6\}\).*/\1/p' | tr -d ' \t;')

                # If hex color is only 3 digits, expand it to 6 digits
                if [ ${#hex_color} -eq 3 ]; then
                    hex_color="${hex_color:0:1}${hex_color:0:1}${hex_color:1:1}${hex_color:1:1}${hex_color:2:1}${hex_color:2:1}"
                fi

                if [ -n "$var_name" ] && [ -n "$hex_color" ]; then
                    # Ensure it's a hex color format (now should be 6 digits)
                    if echo "$hex_color" | grep -qE '^[A-Fa-f0-9]{6}$'; then
                        # Add to temp file with file path
                        echo "$scss_file|$var_name|#${hex_color}|$line" >> "$temp_palette_file"
                    fi
                fi
            done
        fi
    done

    echo "$temp_palette_file"
}

_score_theme_match() {
    # Function to score how well a color palette matches a specific theme
    # This compares dominant colors (excluding most vibrant) against base colors only
    # ($grey*, $black, $white) in a theme
    local colors_data="$1"  # Format: hex|vibrance|percentage|original_line|original_count
    local palette_db="$2"
    local theme_file="$3"   # Specific theme file to score
    local exclude_most_vibrant="$4"  # "1" to exclude most vibrant, "0" to include all

    # Store colors_data to a temp file to avoid subshell issues
    colors_temp_file=$(mktemp)
    echo "$colors_data" > "$colors_temp_file"

    # Get most vibrant color if we need to exclude it
    local most_vibrant_hex=""
    if [ "$exclude_most_vibrant" = "1" ]; then
        # Extract the most vibrant color from colors_data by finding highest vibrance
        local max_vibrance=-1
        while IFS='|' read -r color_hex vibrance percentage original_line original_count; do
            if [ -n "$color_hex" ] && [ -n "$vibrance" ]; then
                # Compare vibrance values numerically
                if [ "$vibrance" -gt "$max_vibrance" ]; then
                    max_vibrance="$vibrance"
                    most_vibrant_hex="$color_hex"
                fi
            fi
        done < "$colors_temp_file"
    fi

    # Initialize total score
    local total_score=0

    # Process each color to compare against this theme's base colors only
    while IFS='|' read -r color_hex vibrance percentage original_line original_count; do
        if [ -n "$color_hex" ] && [ -n "$percentage" ]; then
            # Check if this is the most vibrant color to exclude
            should_skip=0
            if [ "$exclude_most_vibrant" = "1" ] && [ -n "$most_vibrant_hex" ] && [ "$color_hex" = "$most_vibrant_hex" ]; then
                should_skip=1
            fi

            if [ "$should_skip" -eq 0 ]; then
                # Parse percentage as a number for weight
                perc_val=$(echo "$percentage" | awk '{printf "%.6f", $1}')
                if [ "$(echo "$perc_val > 0" | bc -l 2>/dev/null || echo "$perc_val > 0")" = "1" ] || [ "$perc_val" != "0" ]; then
                    # Look for all base colors in this specific theme and calculate aggregate score
                    # Compare against grey, black, white colors
                    local found_base_colors=0
                    local total_similarity=0

                    # For this theme file, find all base colors and compare
                    # Let's use a different approach - extract the specific theme data first
                    local theme_data_file=$(mktemp)
                    grep "^${theme_file}|" "$palette_db" > "$theme_data_file"

                    local processed_entries=0
                    local base_colors_found=0
                    while IFS='|' read -r file_path var_name var_hex line_content; do
                        processed_entries=$((processed_entries + 1))

                        # We know this belongs to the theme since we pre-filtered
                        if [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                            # Check if this is a base/background color from Colloid themes
                            # Remove the leading $ from variable name
                            var_name_stripped=$(echo "$var_name" | sed 's/^\$//')
                            is_base_color=0

                            # Use more reliable pattern matching for base colors
                            case "$var_name_stripped" in
                                grey-*|gray-*|black|white)
                                    is_base_color=1 ;;
                                bg-*|background-*)
                                    is_base_color=1 ;;
                            esac

                            if [ "$is_base_color" -eq 1 ]; then
                                base_colors_found=$((base_colors_found + 1))
                                # Calculate distance to this base color in the theme
                                dist=$(_calculate_color_distance "$color_hex" "$var_hex")

                                # Calculate similarity (higher for closer matches, 0-100 scale)
                                local similarity=$(awk -v d="$dist" 'BEGIN {
                                    # Convert distance to similarity
                                    normalized = d / 441.67;
                                    similarity = (1 - normalized) * 100;
                                    if (similarity < 0) similarity = 0;
                                    printf "%.2f", similarity;
                                }')

                                total_similarity=$(echo "$total_similarity $similarity" | awk '{printf "%.2f", $1 + $2}')
                                found_base_colors=$((found_base_colors + 1))
                            fi
                        fi
                    done < "$theme_data_file"
                    rm -f "$theme_data_file"

                    # Calculate score contribution based on average similarity to base colors
                    if [ "$found_base_colors" -gt 0 ]; then
                        local avg_similarity=$(echo "$total_similarity $found_base_colors" | awk '{printf "%.2f", $1 / $2}')
                        # Calculate score based on average similarity and color percentage
                        local color_score=$(echo "$avg_similarity $perc_val" | awk '{
                            avg_sim = $1;
                            pct = $2;
                            score = (avg_sim / 100.0) * pct;
                            # Ensure score is always calculated properly
                            printf "%.2f", score;
                        }')
                        # Add to the total score for this theme
                        total_score=$(echo "$total_score $color_score" | awk '{printf "%.0f", $1 + $2}')
                    fi
                fi
            fi
        fi
    done < "$colors_temp_file"

    rm -f "$colors_temp_file"

    # Return total score for this theme
    echo "$total_score"
}

_select_best_theme() {
    # Function to select the best matching theme for an image based on overall color palette
    # Excludes the most vibrant color from the base color matching
    # Returns all theme scores for output
    local colors_data="$1"  # Format: hex_color|vibrance|percentage|original_line|original_count
    local palette_db="$2"
    local output_all="${3:-0}"  # 1 to output all scores, 0 to return only best

    temp_scores=$(mktemp)
    # Get unique theme files from palette DB
    themes_list=$(cut -d'|' -f1 "$palette_db" | sort -u)

    for theme_file in $themes_list; do
        if [ -n "$theme_file" ]; then
            theme_score=$(_score_theme_match "$colors_data" "$palette_db" "$theme_file" "1")  # Exclude most vibrant
            echo "$theme_score|$theme_file" >> "$temp_scores"
        fi
    done

    if [ "$output_all" = "1" ]; then
        # Sort by score descending and output all with percentages
        sorted_scores=$(sort -t'|' -k1,1nr "$temp_scores")
        max_score=$(echo "$sorted_scores" | head -n1 | cut -d'|' -f1)

        # If max score is greater than 0, calculate percentages relative to it
        if [ "$max_score" -gt 0 ] && [ "$max_score" != "0" ]; then
            echo "$sorted_scores" | while IFS='|' read -r score theme_file; do
                if [ -n "$score" ] && [ -n "$theme_file" ]; then
                    # Calculate percentage relative to the best score, scaled to 100
                    percentage=$(echo "$score $max_score" | awk '{if($2 > 0) printf "%.2f", ($1/$2)*100; else print "0.00"}')
                    echo "$percentage|$(basename "$theme_file")|$score"
                fi
            done
        else
            # If all scores are 0, just output 0% for all themes
            echo "$sorted_scores" | while IFS='|' read -r score theme_file; do
                if [ -n "$score" ] && [ -n "$theme_file" ]; then
                    echo "0.00|$(basename "$theme_file")|$score"
                fi
            done
        fi
    else
        # Find theme with highest score (sort numerically in reverse order to get highest first)
        best_theme=$(sort -t'|' -k1,1nr "$temp_scores" | head -n 1 | cut -d'|' -f2)
        rm -f "$temp_scores"
        echo "$best_theme"
    fi

    rm -f "$temp_scores"
}

_match_color_to_specific_theme() {
    # Function to match a color against a specific theme's accent colors only
    local target_hex="$1"
    local palette_db="$2"
    local specific_theme="$3"
    local tolerance="${4:-20}"  # Default tolerance of 20
    local best_match=""
    local best_distance=""

    # Remove # prefix if present
    target_hex="${target_hex#'#'}"
    target_hex="#$target_hex"

    # Iterate through palette entries, but only for the specific theme
    while IFS='|' read -r file_path var_name var_hex line_content; do
        if [ "$file_path" = "$specific_theme" ] && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
            # Check if this is an accent color (red, pink, purple, blue, teal, green, yellow, orange)
            var_name_stripped=$(echo "$var_name" | sed 's/^\$//')
            is_accent=0
            case "$var_name_stripped" in
                red-*|pink-*|purple-*|blue-*|teal-*|green-*|yellow-*|orange-*)
                    is_accent=1 ;;
            esac

            # Also include button and link colors as accents
            case "$var_name_stripped" in
                button-*|links|link-*)
                    is_accent=1 ;;
            esac

            if [ "$is_accent" -eq 1 ]; then
                # This is an accent color in the specific theme, calculate distance
                distance=$(_calculate_color_distance "$target_hex" "$var_hex")
                if [ -z "$best_distance" ] || [ "$distance" -lt "$best_distance" ]; then
                    if [ "$distance" -le "$tolerance" ]; then
                        best_distance="$distance"
                        best_match="$file_path|$var_name|$var_hex|$line_content"
                    fi
                fi
            fi
        fi
    done < "$palette_db"

    # If no match within tolerance, find the closest match anyway
    if [ -z "$best_match" ]; then
        while IFS='|' read -r file_path var_name var_hex line_content; do
            if [ "$file_path" = "$specific_theme" ] && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                # Check if this is an accent color
                var_name_stripped="${var_name#'\$'}"
                is_accent=0
                case "$var_name_stripped" in
                    red-*|pink-*|purple-*|blue-*|teal-*|green-*|yellow-*|orange-*)
                        is_accent=1 ;;
                esac

                case "$var_name_stripped" in
                    button-*|links|link-*)
                        is_accent=1 ;;
                esac

                if [ "$is_accent" -eq 1 ]; then
                    # Calculate distance
                    distance=$(_calculate_color_distance "$target_hex" "$var_hex")
                    if [ -z "$best_distance" ] || [ "$distance" -lt "$best_distance" ]; then
                        best_distance="$distance"
                        best_match="$file_path|$var_name|$var_hex|$line_content"
                    fi
                fi
            fi
        done < "$palette_db"
    fi

    echo "$best_match"
}

_match_color_to_palette() {
    # Function to match a color against palette colors (preserving original functionality)
    local target_hex="$1"
    local palette_db="$2"
    local variant="$3"  # "light", "dark", or "any"
    local tolerance="${4:-20}"  # Default tolerance of 20
    local best_match=""
    local best_distance=""
    local closest_match=""  # Closest match regardless of tolerance
    local closest_distance=""

    # Remove # prefix if present
    target_hex="${target_hex#'#'}"
    target_hex="#$target_hex"

    # Iterate through palette entries
    while IFS='|' read -r file_path var_name var_hex line_content; do
        if [ -n "$file_path" ] && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
            # Determine if this color fits the required variant
            case "$variant" in
                "light")
                    if [ "${var_name#*-}" = "light" ] || [ "$var_name" = "\$white" ]; then
                        # Calculate distance
                        distance=$(_calculate_color_distance "$target_hex" "$var_hex")

                        # Track closest match regardless of tolerance
                        if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                            closest_distance="$distance"
                            closest_match="$file_path|$var_name|$var_hex|$line_content"
                        fi

                        # Track best match within tolerance if it exists
                        if [ -z "$best_distance" ] || [ "$distance" -lt "$best_distance" ]; then
                            if [ "$distance" -le "$tolerance" ]; then
                                best_distance="$distance"
                                best_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    fi
                    ;;
                "dark")
                    if [ "${var_name#*-}" = "dark" ] || [ "$var_name" = "\$black" ]; then
                        # Calculate distance
                        distance=$(_calculate_color_distance "$target_hex" "$var_hex")

                        # Track closest match regardless of tolerance
                        if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                            closest_distance="$distance"
                            closest_match="$file_path|$var_name|$var_hex|$line_content"
                        fi

                        # Track best match within tolerance if it exists
                        if [ -z "$best_distance" ] || [ "$distance" -lt "$best_distance" ]; then
                            if [ "$distance" -le "$tolerance" ]; then
                                best_distance="$distance"
                                best_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    fi
                    ;;
                "any")
                    # Calculate distance for any color
                    distance=$(_calculate_color_distance "$target_hex" "$var_hex")

                    # Track closest match regardless of tolerance
                    if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                        closest_distance="$distance"
                        closest_match="$file_path|$var_name|$var_hex|$line_content"
                    fi

                    # Track best match within tolerance if it exists
                    if [ -z "$best_distance" ] || [ "$distance" -lt "$best_distance" ]; then
                        if [ "$distance" -le "$tolerance" ]; then
                            best_distance="$distance"
                            best_match="$file_path|$var_name|$var_hex|$line_content"
                        fi
                    fi
                    ;;
            esac
        fi
    done < "$palette_db"

    # Return best match within tolerance if found, otherwise return the closest match
    if [ -n "$best_match" ]; then
        echo "$best_match"
    else
        echo "$closest_match"
    fi
}

_display_color_preview() {
    # Function to display color preview using ANSI escape codes
    local color="$1"
    local format="$2"

    if [ "$format" = "hex" ]; then
        # Convert hex to RGB for ANSI codes if needed, but for now we'll use the color as provided
        # Extract RGB values from hex for ANSI code
        if [ ${#color} -eq 7 ] && [ "${color#?}" != "$color" ]; then
            # Remove # and extract RGB values
            hex_color="${color#'#'}"
            r=$(printf "%d" 0x${hex_color:0:2})
            g=$(printf "%d" 0x${hex_color:2:2})
            b=$(printf "%d" 0x${hex_color:4:2})
        fi
    else
        # Assuming RGB format: r,g,b
        old_IFS="$IFS"
        IFS=',' read -r r g b << EOF
$color
EOF
        IFS="$old_IFS"
    fi

    # Ensure values are valid and convert to integers for ANSI escape sequence
    # Use awk for safer number handling
    r=$(echo "$r" | awk '{printf "%.0f", $1}')
    g=$(echo "$g" | awk '{printf "%.0f", $1}')
    b=$(echo "$b" | awk '{printf "%.0f", $1}')

    # ANSI escape code for background color
    printf "\\033[48;2;%s;%s;%sm    \\033[0m %s\\n" "$r" "$g" "$b" "$color"
}


_false() {
    return 1
}


_check_deps() {
    if command -v "awk" >/dev/null 2>&1; then
        awk_bin="awk"
    elif busybox awk 1 /dev/null >/dev/null 2>&1; then
        awk_bin="busybox awk"
    else
        printf "%s\\n" "Error: 'awk' is required to run this program. Please install gawk or mawk." >&2
        exit 1
    fi

    if ! command -v "convert" >/dev/null 2>&1; then
        printf "%s\\n" "Error: 'convert' (ImageMagick) is required to run this program. Please install ImageMagick." >&2
        exit 1
    fi
}

_sanitize_parameters(){
    if [ -z "${num_colors}" ]; then
        num_colors="16"
    else
        _is_int "${num_colors}" || _die "Option -n|--numcolors requires a number parameter '${num_colors}'"
    fi

    if [ -z "${deviation}" ]; then
        deviation="1"
    else
        _is_int "${deviation}" || _die "Option -d|--deviation requires a number parameter '${deviation}'"
    fi

    if [ -z "${format}" ]; then
        format="hex"
    else
        case "${format}" in
            rgb|hex) : ;;
            *) _die "Output valid formats are rgb|hex: '${format}'" ;;
        esac
    fi

    if [ -z "${resize}" ]; then
        resize="25x25"
    else
        _is_resize_format "${resize}" || _die "Option -r|--resize requires a format like '25x25': '${resize}'"
    fi

    if [ -z "${sort}" ]; then
        sort="percentage"
    else
        case "${sort}" in
            percentage|vibrance) : ;;
            *) _die "Output sort methods are percentage|vibrance: '${sort}'" ;;
        esac
    fi
}

# Initialize preview, sort method, colortheme, and method flags
preview=""
sort="percentage"  # Default to sorting by percentage
colortheme=""
method="quantize"  # Default to quantize for better results
resize="800x600"   # Default to larger resize for better color detection

if [ ! -t 0 ]; then
    #there is input comming from pipe or file, add to the end of $@
    set -- "${@}" $(cat)
fi

for arg in "${@}"; do #parse options
    case "${arg}" in
        --version) printf "%s %s\\n" "${PROGNAME}" "1.1"; exit ;;
        -h|--help) _usage && exit ;;
        '-p'|'--preview') preview="1"; shift ;;
        '-q'|'--quiet') quiet="1"; shift ;;
        '-d'|'--deviation')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; deviation="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -d*) deviation="${1#-d}"; shift ;;
        --deviation*) deviation="${1#--deviation}"; shift ;;
        '-n'|'--numcolors')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; num_colors="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -n*) num_colors="${1#-n}"; shift ;;
        --numcolors*) num_colors="${1#--numcolors}"; shift ;;
        '-r'|'--resize')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; resize="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -r*) resize="${1#-r}"; shift ;;
        --resize*) resize="${1#--resize}"; shift ;;
        '-f'|'--format')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; format="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        '-s'|'--sort')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter" ;;
                esac
                shift; sort="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -s*) sort="${1#-s}"; shift ;;
        --sort*) sort="${1#--sort}"; shift ;;
        '-c'|'--colortheme') colortheme="1"; shift ;;
        '-f'|'--format')
            if [ "${#}" -gt "1" ]; then
                case "${2}" in
                    -*) _die "Option '${arg}' requires a parameter"
                esac
                shift; format="${1}"; [ "${1}" ] && shift
            else
                _die "Option '${arg}' requires a parameter"
            fi ;;
        -f*) format="${1#-f}"; shift ;;
        --format*) format="${1#--format}"; shift ;;
        -*) _die "${PROGNAME}: unrecognized option '${arg}'" ;;
    esac
done

_check_deps && _sanitize_parameters && [ "${#}" -eq "0" ] && _die

# Use quantization method only (default method)
for image; do
    if _validate_image "${image}"; then
        # Determine if we need to show percentages (always show percentages for pipe output)
        show_percent="1"

        if [ -n "${colortheme}" ]; then
            # NEW IMPLEMENTATION: Color theme matching - matches base colors first, then accent based on brightness
            # Load color palettes for theme matching
            palette_db=$(_load_color_palettes)

            # Get the quantized colors for analysis
            colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t: -k1,1nr -r)  # Sort by count descending to get dominant color first

            # Calculate brightness category
            # First get the quantized colors to check for black condition
            colors_output_for_brightness=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t: -k1,1nr -r)  # Sort by count descending to get dominant color first

            # Initialize brightness category as non-black
            brightness_category=""

            # Check if the most dominant color is black-like and >80% of the image
            if [ -n "$colors_output_for_brightness" ]; then
                first_line=$(echo "$colors_output_for_brightness" | head -n 1)
                if [ -n "$first_line" ]; then
                    total_pixels=$(echo "$first_line" | cut -d: -f1)
                    color_part=$(echo "$first_line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage of this dominant color
                        all_pixels=$(echo "$colors_output_for_brightness" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$all_pixels" ] && [ "$all_pixels" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $all_pixels" | awk '{printf "%.6f", ($1*100.0)/$2}')

                            # Check if this dominant color is very dark (almost black)
                            IFS=',' read -r r g b <<< "$color_part"
                            r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                            g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                            b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                            # Find max RGB component to determine if color is very dark
                            if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                                max_component="$r_int"
                            elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                                max_component="$g_int"
                            else
                                max_component="$b_int"
                            fi

                            # Use different thresholds based on how dark the color is
                            if [ "$max_component" -lt 15 ]; then
                                # For very dark colors, allow >70% dominance to qualify as black
                                is_over_70=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 70.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_70" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            elif [ "$max_component" -lt 40 ]; then
                                # For moderately dark colors, require >80% dominance to qualify as black
                                is_over_80=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 80.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_80" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            fi
                        fi
                    fi
                fi
            fi

            # If not classified as black, use traditional brightness categorization
            if [ -z "$brightness_category" ]; then
                brightness_value=$(_get_brightness "${image}")
                if [ "$brightness_value" -lt 135 ]; then
                    brightness_category="dark"
                else
                    brightness_category="light"
                fi
            fi

            # Now process colors to get data with vibrance for finding most vibrant
            vibrance_temp_file=$(mktemp)
            echo "$colors_output" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract total pixel count and color
                    total_pixels=$(echo "$line" | cut -d: -f1)
                    color_part=$(echo "$line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage for display
                        resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.6f", ($1*100.0)/$2}')
                        else
                            percentage="0.000000"
                        fi

                        # Calculate vibrance based on saturation (max - min of RGB values)
                        IFS=',' read -r r g b <<< "$color_part"
                        # Ensure values are valid and convert to integers for vibrance calculation
                        r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                        # Calculate saturation as the difference between max and min RGB values
                        # This will give us the vibrance value
                        if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                            max_val="$r_int"
                        elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                            max_val="$g_int"
                        else
                            max_val="$b_int"
                        fi

                        if [ "$r_int" -le "$g_int" ] && [ "$r_int" -le "$b_int" ]; then
                            min_val="$r_int"
                        elif [ "$g_int" -le "$r_int" ] && [ "$g_int" -le "$b_int" ]; then
                            min_val="$g_int"
                        else
                            min_val="$b_int"
                        fi

                        vibrance=$((max_val - min_val))

                        # Convert to hex format for matching
                        hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")

                        # Store for processing (format: hex|vibrance|percentage|original_line|original_count)
                        echo "$hex_color|$vibrance|$percentage|$line|$total_pixels" >> "$vibrance_temp_file"
                    fi
                fi
            done

            # Wait for background process to finish
            wait

            # Select the best matching theme based on base colors only (excluding most vibrant)
            # First sort colors by vibrance to get the most vibrant one to exclude
            sorted_vibrant=$(sort -t'|' -k2,2nr -r "$vibrance_temp_file")
            most_vibrant_hex=$(echo "$sorted_vibrant" | head -n 1 | cut -d'|' -f1)

            # Get all theme scores with percentages
            all_theme_scores=$(_select_best_theme "$sorted_vibrant" "$palette_db" "1")

            # Get the best theme (first line after sorting)
            best_theme_line=$(echo "$all_theme_scores" | head -n 1)
            best_theme_full_path=$(echo "$best_theme_line" | cut -d'|' -f2)
            best_theme_percentage=$(echo "$best_theme_line" | cut -d'|' -f1)

            # Output all theme match percentages
            echo "$all_theme_scores" | while IFS='|' read -r percentage theme_name score; do
                if [ -n "$percentage" ] && [ -n "$theme_name" ] && [ -n "$score" ]; then
                    # Use LC_NUMERIC=C to ensure decimal point format
                    percentage_for_printf=$(echo "$percentage" | tr ',' '.')
                    LC_NUMERIC=C printf "THEME_MATCH: %s (%.2f%%) [score: %s]\\n" "$theme_name" "$percentage_for_printf" "$score"
                fi
            done

            # DEBUG: Print selected theme and most vibrant color
            # echo "DEBUG: Selected theme path: $best_theme_full_path" >&2
            # echo "DEBUG: Most vibrant color: $most_vibrant_hex" >&2
            # echo "DEBUG: Brightness category: $brightness_category" >&2

            # Now match the most vibrant color based on brightness category
            if [ "$brightness_category" = "light" ]; then
                # Case 1: brightness is light - match against main light colors ($<color>-light)
                # Find the closest matching accent color from the chosen theme
                closest_accent_match=""
                closest_distance=""

                # First, show all accent color matches with their percentages
                printf "\\nACCENT_MATCHES:\\n"

                # DEBUG: Print info about accent matching
                # echo "DEBUG: Starting accent matching for light theme" >&2
                # echo "DEBUG: Looking in file: $best_theme_full_path" >&2

                # Iterate through palette entries, but only for the specific selected theme
                while IFS='|' read -r file_path var_name var_hex line_content; do
                    # Check if the file path matches either the full path or basename of the selected theme
                    file_basename=$(basename "$file_path")
                    selected_basename=$(basename "$best_theme_full_path")
                    if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                        # Check if this is a light accent color
                        var_name_stripped=$(echo "$var_name" | sed 's/^\$//')
                        is_light_accent=0
                        case "$var_name_stripped" in
                            red-light|pink-light|purple-light|blue-light|teal-light|green-light|yellow-light|orange-light|red-*|pink-*|purple-*|blue-*|teal-*|green-*|yellow-*|orange-*|*red|*pink|*purple|*blue|*teal|*green|*yellow|*orange|button-*|links|link-*)
                                is_light_accent=1 ;;
                        esac

                        if [ "$is_light_accent" -eq 1 ]; then
                            # Calculate distance to this light accent color
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    fi
                done < "$palette_db"

                # If no accent colors were found in the selected theme, fall back to any color in the theme
                if [ -z "$closest_accent_match" ]; then
                    # Reset variables to find any color in the theme
                    closest_accent_match=""
                    closest_distance=""

                    # Iterate through palette entries again, looking for any color in the selected theme
                    while IFS='|' read -r file_path var_name var_hex line_content; do
                        # Check if the file path matches either the full path or basename of the selected theme
                        file_basename=$(basename "$file_path")
                        selected_basename=$(basename "$best_theme_full_path")
                        if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                            # Calculate distance to this color (any color in theme)
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    done < "$palette_db"
                fi
            elif [ "$brightness_category" = "dark" ] || [ "$brightness_category" = "black" ]; then
                # Case 2 & 3: brightness is dark or black - match against main dark colors ($<color>-dark)
                # Find the closest matching accent color from the chosen theme
                closest_accent_match=""
                closest_distance=""

                # First, show all accent color matches with their percentages
                printf "\\nACCENT_MATCHES:\\n"

                # Iterate through palette entries, but only for the specific selected theme
                while IFS='|' read -r file_path var_name var_hex line_content; do
                    # Check if the file path matches either the full path or basename of the selected theme
                    file_basename=$(basename "$file_path")
                    selected_basename=$(basename "$best_theme_full_path")
                    if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                        # Check if this is a dark accent color
                        var_name_stripped=$(echo "$var_name" | sed 's/^\$//')
                        is_dark_accent=0
                        case "$var_name_stripped" in
                            red-dark|pink-dark|purple-dark|blue-dark|teal-dark|green-dark|yellow-dark|orange-dark|red-*|pink-*|purple-*|blue-*|teal-*|green-*|yellow-*|orange-*|*red|*pink|*purple|*blue|*teal|*green|*yellow|*orange|button-*|links|link-*)
                                is_dark_accent=1 ;;
                        esac

                        if [ "$is_dark_accent" -eq 1 ]; then
                            # Calculate distance to this dark accent color
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    fi
                done < "$palette_db"

                # If no accent colors were found in the selected theme, fall back to any color in the theme
                if [ -z "$closest_accent_match" ]; then
                    # Reset variables to find any color in the theme
                    closest_accent_match=""
                    closest_distance=""

                    # Iterate through palette entries again, looking for any color in the selected theme
                    while IFS='|' read -r file_path var_name var_hex line_content; do
                        # Check if the file path matches either the full path or basename of the selected theme
                        file_basename=$(basename "$file_path")
                        selected_basename=$(basename "$best_theme_full_path")
                        if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                            # Calculate distance to this color (any color in theme)
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    done < "$palette_db"
                fi
            fi

            # Output only one recommendation: closest matching color palette and closest matching accent color
            recommended_theme_name=$(basename "$best_theme_full_path")
            printf "SELECTED_THEME: %s\\n" "$recommended_theme_name"
            printf "BRIGHTNESS: %s\\n" "$brightness_category"

            if [ -n "$closest_accent_match" ]; then
                matching_file=$(echo "$closest_accent_match" | cut -d'|' -f1)
                matching_variable=$(echo "$closest_accent_match" | cut -d'|' -f2)
                matching_hex=$(echo "$closest_accent_match" | cut -d'|' -f3)
                matching_line=$(echo "$closest_accent_match" | cut -d'|' -f4)

                printf "ACCENT_VARIABLE: %s\\n" "$matching_variable"
                printf "ACCENT_VALUE: %s\\n" "($matching_hex)"
            else
                printf "ACCENT_VARIABLE: (no close match found)\\n"
                printf "ACCENT_VALUE: (%s)\\n" "$most_vibrant_hex"
            fi

            # Clean up temp files
            rm -f "$vibrance_temp_file" "$palette_db"
        elif [ -n "${preview}" ]; then
            # Process for preview output
            # Calculate brightness considering black condition
            # First get the quantized colors to check for black condition
            colors_output_for_brightness=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t: -k1,1nr -r)  # Sort by count descending to get dominant color first

            # Initialize brightness category as non-black
            brightness_category=""

            # Check if the most dominant color is black-like and >80% of the image
            if [ -n "$colors_output_for_brightness" ]; then
                first_line=$(echo "$colors_output_for_brightness" | head -n 1)
                if [ -n "$first_line" ]; then
                    total_pixels=$(echo "$first_line" | cut -d: -f1)
                    color_part=$(echo "$first_line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage of this dominant color
                        all_pixels=$(echo "$colors_output_for_brightness" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$all_pixels" ] && [ "$all_pixels" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $all_pixels" | awk '{printf "%.6f", ($1*100.0)/$2}')

                            # Check if this dominant color is very dark (almost black)
                            IFS=',' read -r r g b <<< "$color_part"
                            r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                            g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                            b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                            # Find max RGB component to determine if color is very dark
                            if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                                max_component="$r_int"
                            elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                                max_component="$g_int"
                            else
                                max_component="$b_int"
                            fi

                            # Use different thresholds based on how dark the color is
                            if [ "$max_component" -lt 15 ]; then
                                # For very dark colors, allow >70% dominance to qualify as black
                                is_over_70=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 70.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_70" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            elif [ "$max_component" -lt 40 ]; then
                                # For moderately dark colors, require >80% dominance to qualify as black
                                is_over_80=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 80.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_80" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            fi
                        fi
                    fi
                fi
            fi

            # If not classified as black, use traditional brightness categorization
            if [ -z "$brightness_category" ]; then
                brightness_value=$(_get_brightness "${image}")
                if [ "$brightness_value" -lt 135 ]; then
                    brightness_category="dark"
                else
                    brightness_category="light"
                fi
            fi

            printf "BRIGHTNESS:%s\\n" "${brightness_category}"

            # Use ImageMagick's quantization to reduce colors to the specified number
            colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}')

            # Collect color data with percentage and vibrance for sorting (using pipe delimiter to avoid comma conflicts)
            temp_vibrance_file=$(mktemp)

            echo "$colors_output" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract total pixel count and color
                    total_pixels=$(echo "$line" | cut -d: -f1)
                    color_part=$(echo "$line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage for display
                        resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.6f", ($1*100.0)/$2}')
                        else
                            percentage="0.000000"
                        fi

                        # Calculate vibrance based on saturation (max - min of RGB values)
                        IFS=',' read -r r g b <<< "$color_part"
                        # Ensure values are valid and convert to integers for vibrance calculation
                        r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                        # Calculate saturation as the difference between max and min RGB values
                        # This will give us the vibrance value
                        if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                            max_val="$r_int"
                        elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                            max_val="$g_int"
                        else
                            max_val="$b_int"
                        fi

                        if [ "$r_int" -le "$g_int" ] && [ "$r_int" -le "$b_int" ]; then
                            min_val="$r_int"
                        elif [ "$g_int" -le "$r_int" ] && [ "$g_int" -le "$b_int" ]; then
                            min_val="$g_int"
                        else
                            min_val="$b_int"
                        fi

                        vibrance=$((max_val - min_val))

                        # Store data for sorting - format: "original_count|color_part|percentage|vibrance"
                        # Using pipe delimiter to avoid conflicts with commas in color_part
                        echo "$total_pixels|$color_part|$percentage|$vibrance" >> "$temp_vibrance_file"
                    fi
                fi
            done

            # Wait for all background processes to complete
            wait

            # Sort based on the selected method
            if [ "$sort" = "vibrance" ]; then
                # Sort by vibrance (the 4th field after splitting by pipe, descending)
                sorted_colors=$(sort -t'|' -k4,4nr "$temp_vibrance_file")
            else
                # Sort by percentage (the 3rd field after splitting by pipe, descending)
                sorted_colors=$(sort -t'|' -k3,3nr "$temp_vibrance_file")
            fi

            # Process the sorted output to create preview
            echo "$sorted_colors" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract parts: original_count|color_part|percentage|vibrance
                    original_count=$(echo "$line" | cut -d'|' -f1)
                    color_part=$(echo "$line" | cut -d'|' -f2)
                    percentage=$(echo "$line" | cut -d'|' -f3)
                    # vibrance is in the 4th field but we don't need it for output

                    # Convert RGB to appropriate format based on selected format and ensure integer values
                    IFS=',' read -r r g b <<< "$color_part"
                    r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                    g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                    b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                    if [ "$format" = "rgb" ]; then
                        # Display RGB format with visual preview
                        printf "\\033[48;2;%s;%s;%sm    \\033[0m %s,%s,%s (%s%%)\\n" "$r_int" "$g_int" "$b_int" "$r_int" "$g_int" "$b_int" "$percentage"
                    else
                        # Display hex format with visual preview
                        hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")
                        printf "\\033[48;2;%s;%s;%sm    \\033[0m %s (%s%%)\\n" "$r_int" "$g_int" "$b_int" "$hex_color" "$percentage"
                    fi
                fi
            done

            # Clean up temp file
            rm -f "$temp_vibrance_file"
        elif [ -n "${colortheme}" ]; then
            # Color theme matching mode - NEW IMPLEMENTATION
            # Load color palettes for theme matching
            palette_db=$(_load_color_palettes)

            # Get the quantized colors for analysis
            colors_output=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t: -k1,1nr -r)  # Sort by count descending to get dominant color first

            # Calculate brightness category
            # First get the quantized colors to check for black condition
            colors_output_for_brightness=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t: -k1,1nr -r)  # Sort by count descending to get dominant color first

            # Initialize brightness category as non-black
            brightness_category=""

            # Check if the most dominant color is black-like and >80% of the image
            if [ -n "$colors_output_for_brightness" ]; then
                first_line=$(echo "$colors_output_for_brightness" | head -n 1)
                if [ -n "$first_line" ]; then
                    total_pixels=$(echo "$first_line" | cut -d: -f1)
                    color_part=$(echo "$first_line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage of this dominant color
                        all_pixels=$(echo "$colors_output_for_brightness" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$all_pixels" ] && [ "$all_pixels" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $all_pixels" | awk '{printf "%.6f", ($1*100.0)/$2}')

                            # Check if this dominant color is very dark (almost black)
                            IFS=',' read -r r g b <<< "$color_part"
                            r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                            g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                            b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                            # Find max RGB component to determine if color is very dark
                            if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                                max_component="$r_int"
                            elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                                max_component="$g_int"
                            else
                                max_component="$b_int"
                            fi

                            # Use different thresholds based on how dark the color is
                            if [ "$max_component" -lt 15 ]; then
                                # For very dark colors, allow >70% dominance to qualify as black
                                is_over_70=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 70.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_70" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            elif [ "$max_component" -lt 40 ]; then
                                # For moderately dark colors, require >80% dominance to qualify as black
                                is_over_80=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 80.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_80" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            fi
                        fi
                    fi
                fi
            fi

            # If not classified as black, use traditional brightness categorization
            if [ -z "$brightness_category" ]; then
                brightness_value=$(_get_brightness "${image}")
                if [ "$brightness_value" -lt 135 ]; then
                    brightness_category="dark"
                else
                    brightness_category="light"
                fi
            fi

            # Now process colors to get data with vibrance for finding most vibrant
            vibrance_temp_file=$(mktemp)
            echo "$colors_output" | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    # Extract total pixel count and color
                    total_pixels=$(echo "$line" | cut -d: -f1)
                    color_part=$(echo "$line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage for display
                        resized_total=$(echo "$colors_output" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$resized_total" ] && [ "$resized_total" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $resized_total" | awk '{printf "%.6f", ($1*100.0)/$2}')
                        else
                            percentage="0.000000"
                        fi

                        # Calculate vibrance based on saturation (max - min of RGB values)
                        IFS=',' read -r r g b <<< "$color_part"
                        # Ensure values are valid and convert to integers for vibrance calculation
                        r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                        g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                        b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                        # Calculate saturation as the difference between max and min RGB values
                        # This will give us the vibrance value
                        if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                            max_val="$r_int"
                        elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                            max_val="$g_int"
                        else
                            max_val="$b_int"
                        fi

                        if [ "$r_int" -le "$g_int" ] && [ "$r_int" -le "$b_int" ]; then
                            min_val="$r_int"
                        elif [ "$g_int" -le "$r_int" ] && [ "$g_int" -le "$b_int" ]; then
                            min_val="$g_int"
                        else
                            min_val="$b_int"
                        fi

                        vibrance=$((max_val - min_val))

                        # Convert to hex format for matching
                        hex_color=$(printf "#%02X%02X%02X" "$r_int" "$g_int" "$b_int")

                        # Store for processing (format: hex|vibrance|percentage|original_line|original_count)
                        echo "$hex_color|$vibrance|$percentage|$line|$total_pixels" >> "$vibrance_temp_file"
                    fi
                fi
            done

            # Wait for background process to finish
            wait

            # Select the best matching theme based on base colors only (excluding most vibrant)
            # First sort colors by vibrance to get the most vibrant one to exclude
            sorted_vibrant=$(sort -t'|' -k2,2nr -r "$vibrance_temp_file")
            most_vibrant_hex=$(echo "$sorted_vibrant" | head -n 1 | cut -d'|' -f1)

            # Get all theme scores with percentages
            all_theme_scores=$(_select_best_theme "$sorted_vibrant" "$palette_db" "1")

            # Get the best theme (first line after sorting)
            best_theme_line=$(echo "$all_theme_scores" | head -n 1)
            best_theme_full_path=$(echo "$best_theme_line" | cut -d'|' -f2)
            best_theme_percentage=$(echo "$best_theme_line" | cut -d'|' -f1)

            # Output all theme match percentages
            echo "$all_theme_scores" | while IFS='|' read -r percentage theme_name score; do
                if [ -n "$percentage" ] && [ -n "$theme_name" ] && [ -n "$score" ]; then
                    # Use LC_NUMERIC=C to ensure decimal point format
                    percentage_for_printf=$(echo "$percentage" | tr ',' '.')
                    LC_NUMERIC=C printf "THEME_MATCH: %s (%.2f%%) [score: %s]\\n" "$theme_name" "$percentage_for_printf" "$score"
                fi
            done

            # DEBUG: Print selected theme and most vibrant color
            # echo "DEBUG: Selected theme path: $best_theme_full_path" >&2
            # echo "DEBUG: Most vibrant color: $most_vibrant_hex" >&2
            # echo "DEBUG: Brightness category: $brightness_category" >&2

            # Now match the most vibrant color based on brightness category
            if [ "$brightness_category" = "light" ]; then
                # Case 1: brightness is light - match against main light colors ($<color>-light)
                # Find the closest matching accent color from the chosen theme
                closest_accent_match=""
                closest_distance=""

                # First, show all accent color matches with their percentages
                printf "\\nACCENT_MATCHES:\\n"

                # DEBUG: Print info about accent matching
                # echo "DEBUG: Starting accent matching for light theme" >&2
                # echo "DEBUG: Looking in file: $best_theme_full_path" >&2

                # Iterate through palette entries, but only for the specific selected theme
                while IFS='|' read -r file_path var_name var_hex line_content; do
                    # Check if the file path matches either the full path or basename of the selected theme
                    file_basename=$(basename "$file_path")
                    selected_basename=$(basename "$best_theme_full_path")
                    if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                        # Check if this is a light accent color
                        var_name_stripped=$(echo "$var_name" | sed 's/^\$//')
                        is_light_accent=0
                        case "$var_name_stripped" in
                            red-light|pink-light|purple-light|blue-light|teal-light|green-light|yellow-light|orange-light|red-*|pink-*|purple-*|blue-*|teal-*|green-*|yellow-*|orange-*|*red|*pink|*purple|*blue|*teal|*green|*yellow|*orange|button-*|links|link-*)
                                is_light_accent=1 ;;
                        esac

                        if [ "$is_light_accent" -eq 1 ]; then
                            # Calculate distance to this light accent color
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    fi
                done < "$palette_db"

                # If no accent colors were found in the selected theme, fall back to any color in the theme
                if [ -z "$closest_accent_match" ]; then
                    # Reset variables to find any color in the theme
                    closest_accent_match=""
                    closest_distance=""

                    # Iterate through palette entries again, looking for any color in the selected theme
                    while IFS='|' read -r file_path var_name var_hex line_content; do
                        # Check if the file path matches either the full path or basename of the selected theme
                        file_basename=$(basename "$file_path")
                        selected_basename=$(basename "$best_theme_full_path")
                        if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                            # Calculate distance to this color (any color in theme)
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    done < "$palette_db"
                fi
            elif [ "$brightness_category" = "dark" ] || [ "$brightness_category" = "black" ]; then
                # Case 2 & 3: brightness is dark or black - match against main dark colors ($<color>-dark)
                # Find the closest matching accent color from the chosen theme
                closest_accent_match=""
                closest_distance=""

                # First, show all accent color matches with their percentages
                printf "\\nACCENT_MATCHES:\\n"

                # Iterate through palette entries, but only for the specific selected theme
                while IFS='|' read -r file_path var_name var_hex line_content; do
                    # Check if the file path matches either the full path or basename of the selected theme
                    file_basename=$(basename "$file_path")
                    selected_basename=$(basename "$best_theme_full_path")
                    if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                        # Check if this is a dark accent color
                        var_name_stripped=$(echo "$var_name" | sed 's/^\$//')
                        is_dark_accent=0
                        case "$var_name_stripped" in
                            red-dark|pink-dark|purple-dark|blue-dark|teal-dark|green-dark|yellow-dark|orange-dark|red-*|pink-*|purple-*|blue-*|teal-*|green-*|yellow-*|orange-*|*red|*pink|*purple|*blue|*teal|*green|*yellow|*orange|button-*|links|link-*)
                                is_dark_accent=1 ;;
                        esac

                        if [ "$is_dark_accent" -eq 1 ]; then
                            # Calculate distance to this dark accent color
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    fi
                done < "$palette_db"

                # If no accent colors were found in the selected theme, fall back to any color in the theme
                if [ -z "$closest_accent_match" ]; then
                    # Reset variables to find any color in the theme
                    closest_accent_match=""
                    closest_distance=""

                    # Iterate through palette entries again, looking for any color in the selected theme
                    while IFS='|' read -r file_path var_name var_hex line_content; do
                        # Check if the file path matches either the full path or basename of the selected theme
                        file_basename=$(basename "$file_path")
                        selected_basename=$(basename "$best_theme_full_path")
                        if ([ "$file_path" = "$best_theme_full_path" ] || [ "$file_basename" = "$selected_basename" ]) && [ -n "$var_name" ] && [ -n "$var_hex" ]; then
                            # Calculate distance to this color (any color in theme)
                            distance=$(_calculate_color_distance "$most_vibrant_hex" "$var_hex")
                            # Calculate similarity percentage (lower distance = higher similarity)
                            # Maximum possible distance is 441.67 (distance between #000000 and #FFFFFF)
                            similarity_percentage=$(echo "$distance" | awk '{printf "%.2f", (1 - ($1/441.67)) * 100}')
                            # Handle potential comma issue in similarity_percentage
                            similarity_percentage_fixed=$(echo "$similarity_percentage" | sed 's/,/./g')

                            similarity_percentage_for_printf=$(echo "$similarity_percentage_fixed" | tr ',' '.')
                            LC_NUMERIC=C printf "  %s: %s (%.2f%%) [distance: %s]\\n" "$var_name" "$var_hex" "$similarity_percentage_for_printf" "$distance"

                            if [ -z "$closest_distance" ] || [ "$distance" -lt "$closest_distance" ]; then
                                closest_distance="$distance"
                                closest_accent_match="$file_path|$var_name|$var_hex|$line_content"
                            fi
                        fi
                    done < "$palette_db"
                fi
            fi

            # Output only one recommendation: closest matching color palette and closest matching accent color
            recommended_theme_name=$(basename "$best_theme_full_path")
            printf "SELECTED_THEME: %s\\n" "$recommended_theme_name"
            printf "BRIGHTNESS: %s\\n" "$brightness_category"

            if [ -n "$closest_accent_match" ]; then
                matching_file=$(echo "$closest_accent_match" | cut -d'|' -f1)
                matching_variable=$(echo "$closest_accent_match" | cut -d'|' -f2)
                matching_hex=$(echo "$closest_accent_match" | cut -d'|' -f3)
                matching_line=$(echo "$closest_accent_match" | cut -d'|' -f4)

                printf "ACCENT_VARIABLE: %s\\n" "$matching_variable"
                printf "ACCENT_VALUE: %s\\n" "($matching_hex)"
            else
                printf "ACCENT_VARIABLE: (no close match found)\\n"
                printf "ACCENT_VALUE: (%s)\\n" "$most_vibrant_hex"
            fi

            # Clean up temp files
            rm -f "$vibrance_temp_file" "$palette_db"
        else
            # For non-preview mode, always show brightness and colors with percentages
            # First get the quantized colors to check for black condition
            colors_output_for_brightness=$(convert "${image}" -resize "${resize}" -depth 8 +dither -colors "${num_colors}" \
                -format "%c" histogram:info: 2>/dev/null | \
                awk 'NF {sub(/\).*/,"");sub(/\(/,"");gsub(/ /,"");print $0}' | \
                sort -t: -k1,1nr -r)  # Sort by count descending to get dominant color first

            # Initialize brightness category as non-black
            brightness_category=""

            # Check if the most dominant color is black-like and >80% of the image
            if [ -n "$colors_output_for_brightness" ]; then
                first_line=$(echo "$colors_output_for_brightness" | head -n 1)
                if [ -n "$first_line" ]; then
                    total_pixels=$(echo "$first_line" | cut -d: -f1)
                    color_part=$(echo "$first_line" | cut -d: -f2-)

                    if [ -n "$total_pixels" ] && [ -n "$color_part" ]; then
                        # Calculate percentage of this dominant color
                        all_pixels=$(echo "$colors_output_for_brightness" | awk 'BEGIN{sum=0}{split($0, a, ":"); sum += a[1]} END{print sum}')
                        if [ -n "$all_pixels" ] && [ "$all_pixels" -gt 0 ]; then
                            percentage=$(echo "$total_pixels $all_pixels" | awk '{printf "%.6f", ($1*100.0)/$2}')

                            # Check if this dominant color is very dark (almost black)
                            IFS=',' read -r r g b <<< "$color_part"
                            r_int=$(echo "$r" | awk '{printf "%.0f", $1}')
                            g_int=$(echo "$g" | awk '{printf "%.0f", $1}')
                            b_int=$(echo "$b" | awk '{printf "%.0f", $1}')

                            # Find max RGB component to determine if color is very dark
                            if [ "$r_int" -ge "$g_int" ] && [ "$r_int" -ge "$b_int" ]; then
                                max_component="$r_int"
                            elif [ "$g_int" -ge "$r_int" ] && [ "$g_int" -ge "$b_int" ]; then
                                max_component="$g_int"
                            else
                                max_component="$b_int"
                            fi

                            # Use different thresholds based on how dark the color is
                            if [ "$max_component" -lt 15 ]; then
                                # For very dark colors, allow >70% dominance to qualify as black
                                is_over_70=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 70.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_70" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            elif [ "$max_component" -lt 40 ]; then
                                # For moderately dark colors, require >80% dominance to qualify as black
                                is_over_80=$(echo "$percentage" | awk '
                                {
                                    if ($1 > 80.0) print "yes"
                                    else print "no"
                                }')
                                if [ "$is_over_80" = "yes" ]; then
                                    brightness_category="black"
                                fi
                            fi
                        fi
                    fi
                fi
            fi

            # If not classified as black, use traditional brightness categorization
            if [ -z "$brightness_category" ]; then
                brightness_value=$(_get_brightness "${image}")
                if [ "$brightness_value" -lt 135 ]; then
                    brightness_category="dark"
                else
                    brightness_category="light"
                fi
            fi

            # Output brightness mode and colors sorted by percentage for piping to other scripts
            printf "BRIGHTNESS:%s\\n" "${brightness_category}"
            _quantize_colors "${image}" "${num_colors}" "${format}" "${sort}" ""  # Always show percentages, no brightness header
        fi
    else
        if [ -z "${quiet}" ]; then
            printf "%s\\n" "Warning: '${image}' doesn't exist, skipping..." >&2
        fi
        _false
    fi
done
